<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Logistic regression!</title>
    <meta charset="utf-8" />
    <meta name="author" content="  Laxmikant  " />
    <script src="libs/header-attrs-2.1/header-attrs.js"></script>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-155379268-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

       gtag('config','UA-155379268-1');
    </script>

     <script type="application/ld+json">
    {
      "@context": "http://schema.org",
      "@type": "BlogPosting",
      "headline": "R Markdown",
      "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://laxmikants.github.io/R-markdown/slides/Lession1.html"
      },
      "image": {
        "@type": "ImageObject",
        "url": "https://laxmikants.github.io/img/cover.png",
        "width": 800,
        "height": 600
      },
      "genre": "post",
      "keywords": "R Markdown",
      "wordcount": 159,
      "url": "https://laxmikants.github.io/R-markdown/slides/Lession1.html",
      "datePublished": "2017-07-23T00:00:00+00:00",
      "dateModified": "2017-07-23T00:00:00+00:00",
      "license": "This work is licensed.",
       "publisher" : {
        "@type": "Organization",
        "name" : "Laxmikant",
        "logo" : {
            "@type" : "ImageObject",
            "url" : "https://laxmikants.github.io/img/avatar-icon.png",
          "width": 60,
          "height": 60
        }
      },
      "author": {
        "@type": "Person",
        "name": "Laxmikant"
      },
      "description" : "R markdown"
    }
    </script>

      <meta charset="utf-8" />
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">

      <title>Data Science Posts and Resources | Laxmikant</title>
      <meta property="og:title" content="Posts and Resources on Data Science | R Markdown" />
      <meta name="description" content="Implementing R markdown">
      <meta property="og:description" content="Implementing R markdown">
      <meta name="author" content="Laxmikant"/>
    <script type="application/ld+json">
    {
      "@context": "http://schema.org",
      "@type": "Article",
      "author": {
        "@type": "Person",
        "name" : "Laxmikant"
      },
      "headline": "R Markdown",
      "description" : "Implementing R markdown",
      "inLanguage" : "en",
      "wordCount": 159,
      "datePublished" : "2017-07-23T00:00:00",
      "dateModified" : "2017-07-23T00:00:00",
      "image" : "https://laxmikants.github.io/img/avatar-icon.png",
      "keywords" : [ "R Markdown, plot, regression" ],
      "mainEntityOfPage" : "https://laxmikants.github.io/R-markdown/slides/Lession1.html",
      "publisher" : {
        "@type": "Organization",
        "name" : "Laxmikant",
        "logo" : {
            "@type" : "ImageObject",
            "url" : "https://laxmikants.github.io/img/avatar-icon.png",
            "height" :  60 ,
            "width" :  60
        }
      }
    }
    </script>

    <link href='https://laxmikants.github.io/img/favicon.ico' rel='icon' type='image/x-icon'/>
    <meta property="og:image" content="https://laxmikants.github.io/img/avatar-icon.png" />
    <meta property="og:url" content="https://laxmikants.github.io/post/2015-07-23-r-rmarkdown/" />
    <meta property="og:type" content="article" />
    <meta property="og:site_name" content="Laxmikant" />
    <meta property="og:description" content="posts, Tutorials and resources for Data Science programming languages, frameworks, tools, etc.">
    <meta property="og:locale" content="en_IN" />
    <meta property="og:type" content="article" />

    <meta content="R markdown" property="og:description">
    <meta property="og:url" content="https://laxmikants.github.io/R-markdown/slides/Lession1.html" />
    <meta property="og:site_name" content="Laxmikant" />
    <meta property="article:section" content="R" />
    <meta property="article:published_time" content="2017-07-23 00:00:00 &#43;0000 UTC" />
    <meta name="generator" content="Hugo 0.54.0" />
    <link rel="stylesheet" href="https:\\laxmikants.github.io\css\default.css" type="text/css" />
    <link rel="stylesheet" href="https:\\laxmikants.github.io\css\metropolis.css" type="text/css" />
    <link rel="stylesheet" href="https:\\laxmikants.github.io\css\metropolis-fonts.css" type="text/css" />
    <link rel="stylesheet" href="https:\\stackpath.bootstrapcdn.com\bootstrap\4.3.1\css\bootstrap-grid.min.css" type="text/css" />
    <link rel="stylesheet" href="https:\\laxmikants.github.io\css\my_styles.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">

class: title-slide



.row[
.col-7[
.title[
# Logistic Regression
]
.subtitle[
## Logistic regression  
]
.author[
### Laxmikant Soni &lt;br&gt; [Web-Site](https://laxmikants.github.io) &lt;br&gt; [&lt;i class="fab fa-github"&gt;&lt;/i&gt;](https://github.com/laxmiaknts) [&lt;i class="fab fa-twitter"&gt;&lt;/i&gt;](https://twitter.com/laxmikantsoni09)
]

.affiliation[
]

]

.col-5[

.logo[
&lt;img src="figures/rmarkdown.png" width="281" /&gt;
]


]

]


---
class: very-large-body

# Logistic Regression 


.pull-top[

Logistic regression is an approach to classification problems.

Instead of our output vector y being a continuous range of values, it will only be 0 or 1 ie `\(y \in [0,1]\)`

Where 0 is usually taken as the “negative class” and 1 as the “positive class”, but you are free to assign any representation to it.

One method is to use linear regression and map all predictions greater than 0.5 as a 1 and all less than 0.5 as a 0. This method doesn’t work well because classification is not actually a linear function.


]


---
class: large-body

# Hypothesis function

.pull-top[


Our hypothesis should satisfy:

`\(0 \leq h_\theta (x) \leq 1\)`

Our new form uses the “Sigmoid Function,” also called the “Logistic Function”: `\(h_\theta (x) = g(\theta^T x)\)`, `\(z = \theta^T x\)` , `\(g(z) = \frac {1}{1 + e^{-z}}\)`

![alt text](figures/logistic.png)


The function g(z), shown here, maps any real number to the (0, 1) interval, making it useful for transforming an arbitrary-valued function into a function better suited for classification.

We start with our old hypothesis (linear regression), except that we want to restrict the range to 0 and 1. This is accomplished by plugging `\(\theta^T x\)` into the Logistic Function.
`\(h_\theta\)` will give us the probability that our output is 1.

`\(h_\theta(x) = P(y=1|x;\theta) = 1 - P(y = 0|x;\theta)\)`

`\(P(y = 0 | x; \theta) + P(y=1|x;\theta) = 1\)`
]

---

class: large-body

# Decision Boundray

.pull-top[



In order to get our discrete 0 or 1 classification, we can translate the output of the hypothesis function as follows:

`\(h_\theta(x) \geq 0.5 \rightarrow y = 1\)`

`\(h_\theta(x) &lt; 0.5 \rightarrow y = 0\)`

The way our logistic function g behaves is that when its input is greater than or equal to zero, its output is greater than or equal to 0.5:

`\(g(z) \geq 0.5\)`  `\(when \ z \geq 0\)`

`\(z = 0, e^0 = 1 \rightarrow g(z) = \frac{1}{2}\)`

`\(z \rightarrow \infty , e^{\neg \infty} \rightarrow 0 \rightarrow g(z) = 1\)`

`\(z \rightarrow  \neg \infty , e^{ \infty} \rightarrow \infty \rightarrow g(z) = 0\)`

So if our input to g is `\(\theta^T X\)` then that means

`\(h_\theta (x) = g(\theta^T x) \geq 0.5\)` `\(when  \ \theta^T x \geq 0\)`
]

---

class: large-body

# Decision Boundray

.pull-top[


From these statements we can now say:

`\(\theta^T x \geq 0 \rightarrow y = 1\)`

`\(\theta^T x \leq \rightarrow = 0\)`

The decision boundary is the line that separates the area where y = 0 and where y = 1. It is created by our hypothesis function.

Example:

`\(\left [\matrix {5 \\ \neg 1 \\ 0} \right ]\)`


`\(y = 1 \ if \ 5 + (-1)x_1 + 0x_2 \geq 0\)`

`\(5 - x_1 \geq 0\)`

`\(-x_1 \geq -5\)`

`\(x_1 \geq 5\)`

In this case, our decision boundary is a straight vertical line placed on the graph where x1=5, and everything to the left of that denotes y = 1, while everything to the right denotes y = 0.

Again, the input to the sigmoid function g(z) doesn’t need to be linear, and could be a function that describes a circle (e.g. `\(z = \theta_0 + \theta_1 x_1^2 + \theta_2 x_2^2\)` or any shape to fit our data.
]

---



class: large-body

# Cost Function

.pull-top[


We cannot use the same cost function that we use for linear regression because the Logistic Function will cause the output to be wavy, causing many local optima. In other words, it will not be a convex function.

Instead, our cost function for logistic regression looks like:

`\(J (\theta) = \frac {1} {m} \sum_{i = 1}^{m} Cost(h_\theta(x^{(ij)}), y^{(ij)})\)`

`\(Cost(h_\theta (x), y) = -log(h_\theta (x)) \ if \ y = 1\)`

`\(Cost(h_\theta (x), y) = -log(1 - h_\theta (x)) \ if \ y = 0\)`

![alt text](figures/logistic1.png)

![alt text](figures/logistic2.png)

]

---

class: large-body

# Cost function

.pull-top[


For the parameter vector `\(\theta\)`, the cost function is 

`\(J(\theta) = \frac{1}{2m} \sum_{i=1}^{m} (h_\theta (x_i) - y_i)^2\)`

The vectorized version is:

`\(J(\theta) = \frac{1}{2m} (X \theta - \bar{y})^T (X \theta - \bar{y})\)`

where `\(\bar{y}\)` denotes the vector of all y values



]

---

class: large-body

# Gradient Descent for Multiple Variables

.pull-top[


The gradient descent equation itself is generally the same form; we just have to repeat it for our ‘n’ features:

repeat until convergence:

`\(\theta_0 := \theta_0 - \alpha \frac{1}{m} \sum_{i = 1}^{m} (h_\theta(x^{(i)}) - y^{(i)}) * x_0^{(i)}\)`

`\(\theta_1 := \theta_1 - \alpha \frac{1}{m} \sum_{i = 1}^{m} (h_\theta(x^{(i)}) - y^{(i)}) * x_1^{(i)}\)`

`\(\theta_2 := \theta_2 - \alpha \frac{1}{m} \sum_{i = 1}^{m} (h_\theta(x^{(i)}) - y^{(i)}) * x_2^{(i)}\)`

In other words:

repeat until convergence: {

`\(\theta_j := \theta_j - \alpha \frac{1}{m} \sum_{i = 1}^{m} (h_\theta(x^{(i)}) - y^{(i)}) * x_0^{(i)} \  for \ j := 0..n\)`

}

]


---

class: large-body

# Feature normalization

.pull-top[


 Mean normalization involves subtracting the average value for an input variable from the values for that input variable, resulting in a new average value for the input variable of just zero. To implement both of these techniques, adjust your input values as shown in this formula:
 
`\(x_i := \frac{x_i - \mu_i}{s_i}\)`

Where μi is the average of all the values for feature (i) and si is the range of values (max - min), or si is the standard deviation.

]

---


class: large-body

# Features and polynomial regression 

.pull-top[


We can improve our features and the form of our hypothesis function in a couple different ways.


Our hypothesis function need not be linear (a straight line) if that does not fit the data well.

We can change the behavior or curve of our hypothesis function by making it a quadratic, cubic or square root function (or any other form).

`\(h_\theta(x) = \theta_0 + \theta_1 x_1 + \theta_2 x_1^2 + \theta_3 x_1^3\)`

To make it a square root function, we could do `\(h_\theta(x) = \theta_0 + \theta_1 x_1 + \theta_2 \sqrt{x_1}\)`


]

---

class: large-body

# Normal Equation 

.pull-top[


The “Normal Equation” is a method of finding the optimum theta without iteration.

`\(\theta = (X^T X)^{-1} X^T y\)`

There is no need to do feature scaling with the normal equation.



]

---



class: inverse, center, middle
# Thanks

---
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script src="https://laxmikants.github.io/js/cols_macro.js"></script>
<script>var slideshow = remark.create({
"highlightLines": true,
"countIncrementalSlides": false,
"ratio": "16:9",
"navigation": {
"scroll": false
}
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
