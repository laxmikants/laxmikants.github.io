<!doctype html>
<html lang="en" itemscope itemtype="http://schema.org/WebPage">
  <head>
  <style>

    .nocopy {
      -webkit-user-select: none;   
      -moz-user-select: none;      
      -ms-user-select: none;       
      user-select: none;           
    }  

</style>

<script data-ad-client="ca-pub-3804322353139756" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<script async src = "https://www.googletagmanager.com/gtag/js?id=UA-155379268-1"></script>
<script>
 window.dataLayer = window.dataLayer || [];
 function gtag(){dataLayer.push(arguments);}
 gtag('js',new Date());
 
 gtag('config','UA-155379268-1');

</script>  
  <meta charset="utf-8">
<title>Python - Multithreading - Data Science Posts and Resources :: Laxmikant Soni</title>
<meta name="viewport" content="width=device-width,initial-scale=1, maximum-scale=1, minimum-scale = 1, user-scalable = no">

<meta name="google-site-verification" content="MeRcFEBEyWiTb3NfY4THWxbV_fx3rKOJnvr_Jk398wY" />

<meta name=keywords content="Articles and Posts on Python, R, Data Science, Machine Learning and Analytics | Laxmikant Soni, Predictive Analytics, Business, Data, Analytics, Machine Learning, Mining, Python, Intelligence, Big, Modeling, Data Science, Integration, Visualization,Statistical population,Probability,False positives,Statistical inference,Regression,Fitting,Categorical data,Classification,Clustering,Statistical comparison,CodingDistributions,Data mining,Decision trees,Machine learning,Munging and wrangling,Visualization,D3,Regularization,Assessment,Cross-validation,Neural networks,Boosting,Lift,Mode,Outlier,Predictive modeling,Big data,Confidence interval,Python,R,Jupyter Notebook,Tensorflow,Javascript,ReactJS,NodeJS,Posts and Resources on Data Science,Data Science,Hadoop,Java,Spring,Hibernate,Struts,MySQL,Oracle,DB2,Websphere,Weblogic">

<meta name=description content="Articles and Posts on Python, R, Data Science, Machine Learning and Analytics :: Laxmikant Soni">

<meta name="robots" content="index">


<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>

<link rel="stylesheet"href= "https://maxcdn.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" /> 



<meta name="generator" content="Hugo 0.80.0" /><meta itemprop="name" content="Python - Multithreading">
<meta itemprop="description" content="Introduction to Python Multithreading">
<meta itemprop="datePublished" content="2019-01-19T00:00:00+00:00" />
<meta itemprop="dateModified" content="2019-01-19T00:00:00+00:00" />
<meta itemprop="wordCount" content="2158">



<meta itemprop="keywords" content="Python," />
<meta property="og:title" content="Python - Multithreading" />
<meta property="og:description" content="Introduction to Python Multithreading" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://laxmikants.github.io/blog/python-multithreading/" />
<meta property="article:published_time" content="2019-01-19T00:00:00+00:00" />
<meta property="article:modified_time" content="2019-01-19T00:00:00+00:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Python - Multithreading"/>
<meta name="twitter:description" content="Introduction to Python Multithreading"/>
<meta name="twitter:site" content="@laxmikantsoni09"/>
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.0.3/styles/monokai.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css">
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Raleway:400,800,900|Source+Sans+Pro:400,700">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.8.6/css/academicons.min.css">
        <script src="https://kit.fontawesome.com/be54eb011a.js" crossorigin="anonymous"></script>
      <script async   src="https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML"> </script>
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="/css/main.min.aa4e8165f5b2a16460fcb21582ad412bed8e48e9c5dc49f3b412d1703be4d75d.css" integrity="sha256-qk6BZfWyoWRg/LIVgq1BK&#43;2OSOnF3EnztBLRcDvk110="><link rel="stylesheet" href="/css/add-on.css">

<title>Python - Multithreading : Data Science Posts and Resources</title>

<meta property="og:title" content="Python - Multithreading">
<meta property="og:site_name" content="Data Science Posts and Resources">
<meta property="og:url" content="https://laxmikants.github.io/blog/python-multithreading/">
<meta property="og:type" content="article">
<meta property="og:locale" content="en">
<meta property="og:description" content="Introduction to Python Multithreading">
<meta name="description" content="Introduction to Python Multithreading">
<meta property="og:updated_time" content="2019-01-19T00:00:00Z">
<meta property="fb:app_id" content="428818034507005">
<meta name="author" content="Laxmikant Soni">
<meta property="article:author" content="https://laxmikants.github.io">
<meta property="article:published_time" content="2019-01-19T00:00:00Z">
<meta property="article:modified_time" content="2019-01-19T00:00:00Z">
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "Article",
  "headline": "Python - Multithreading",
  "alternativeHeadline": "Python Multithreading",
  "url": "https://laxmikants.github.io/blog/python-multithreading/",
  "image": "https://laxmikants.github.io/",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://laxmikants.github.io/blog/python-multithreading/"
  },
  "description": "Introduction to Python Multithreading",
  "author": {
    "@type": "Person",
    "name": "Laxmikant Soni"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Data Science Posts and Resources",
    "logo": {
      "@type": "ImageObject",
      "url": "https://laxmikants.github.io/"
    }
  },
  "datePublished": "2019-01-19T00:00:00Z",
  "dateModified": "2019-01-19T00:00:00Z",
  "articleBody": "\r\n\u003cscript src=\"/rmarkdown-libs/header-attrs/header-attrs.js\"\u003e\u003c/script\u003e\r\n\u003clink href=\"/rmarkdown-libs/anchor-sections/anchor-sections.css\" rel=\"stylesheet\" /\u003e\r\n\u003cscript src=\"/rmarkdown-libs/anchor-sections/anchor-sections.js\"\u003e\u003c/script\u003e\r\n\r\n\u003cdiv id=\"TOC\"\u003e\r\n\u003cul\u003e\r\n\u003cli\u003e\u003ca href=\"#multithreading\"\u003eMultithreading\u003c/a\u003e\r\n\u003cul\u003e\r\n\u003cli\u003e\u003ca href=\"#how-a-thread-works\"\u003eHow a thread works\u003c/a\u003e\r\n\u003cul\u003e\r\n\u003cli\u003e\u003ca href=\"#how-to-start-thread\"\u003ehow to start thread\u003c/a\u003e\u003c/li\u003e\r\n\u003cli\u003e\u003ca href=\"#start-vs-run\"\u003eStart Vs Run\u003c/a\u003e\u003c/li\u003e\r\n\u003cli\u003e\u003ca href=\"#waiting-for-threads\"\u003eWaiting for threads\u003c/a\u003e\u003c/li\u003e\r\n\u003cli\u003e\u003ca href=\"#thread-classes\"\u003eThread classes\u003c/a\u003e\u003c/li\u003e\r\n\u003cli\u003e\u003ca href=\"#synchronizing-threads\"\u003eSynchronizing Threads\u003c/a\u003e\u003c/li\u003e\r\n\u003c/ul\u003e\u003c/li\u003e\r\n\u003c/ul\u003e\u003c/li\u003e\r\n\u003cli\u003e\u003ca href=\"#semaphores\"\u003eSemaphores\u003c/a\u003e\r\n\u003cul\u003e\r\n\u003cli\u003e\u003ca href=\"#daemon-threads\"\u003eDaemon Threads\u003c/a\u003e\u003c/li\u003e\r\n\u003c/ul\u003e\u003c/li\u003e\r\n\u003c/ul\u003e\r\n\u003c/div\u003e\r\n\r\n\u003chr\u003e\r\n\u003cdiv id=\"multithreading\" class=\"section level1\"\u003e\r\n\u003ch1\u003eMultithreading\u003c/h1\u003e\r\n\u003cp\u003eThreads are lightweight processes that perform certain actions in a program and they are part of a process themselves. These threads can work in parallel with each other in the same way as two individual applications can.\u003c/p\u003e\r\n\u003cp\u003eSince threads in the same process share the memory space for the variables and the data, they can exchange information and communicate efficiently. Also, threads need fewer resources than processes. That’s why they’re often called lightweight processes.\u003c/p\u003e\r\n\u003cdiv id=\"how-a-thread-works\" class=\"section level2\"\u003e\r\n\u003ch2\u003eHow a thread works\u003c/h2\u003e\r\n\u003cp\u003eA thread has a beginning or a start, a working sequence and an end. But it can also be stopped or put on hold at any time. The latter is also called sleep .\r\nThere are two types of threads: Kernel Threads and User Threads . Kernel threads are part of the operating system, whereas user threads are managed by the programmer. That’s why we will focus on user threads in this book.\u003c/p\u003e\r\n\u003cp\u003eIn Python, a thread is a class that we can create instances of. Each of these instances then represents an individual thread which we can start, pause or stop. They are all independent from each other and they can perform different operations at the same time.\u003c/p\u003e\r\n\u003cp\u003eFor example, in a video game, one thread could be rendering all the graphics, while another thread processes the keyboard and mouse inputs. It would be unthinkable to serially perform these tasks one after the other.\u003c/p\u003e\r\n\u003cdiv id=\"how-to-start-thread\" class=\"section level3\"\u003e\r\n\u003ch3\u003ehow to start thread\u003c/h3\u003e\r\n\u003cp\u003eIn order to work with threads in Python, we will need to import the respective library threading .\u003c/p\u003e\r\n\u003cpre class=\"python\"\u003e\u003ccode\u003eimport threading\u003c/code\u003e\u003c/pre\u003e\r\n\u003cp\u003eThen, we need to define our target function. This will be the function that contains the code that our thread shall be executing. Let’s just keep it simple for the beginning and write a hello world function.\u003c/p\u003e\r\n\u003cpre class=\"python\"\u003e\u003ccode\u003eimport threading\r\ndef hello():\r\n  print ( \u0026#39;Hello World!\u0026#39; )\r\n  t1 = threading.Thread( target =hello)\r\n  t1.start()\u003c/code\u003e\u003c/pre\u003e\r\n\u003cp\u003eAfter we have defined the function, we create our first thread. For this, we use the class Thread of the imported threading module. As a parameter, we specify the target to be the hello function. Notice that we don’t put parentheses after our function name here, since we are not calling it but just referring to it. By using the start method we put our thread to work and it executes our function.\u003c/p\u003e\r\n\u003c/div\u003e\r\n\u003cdiv id=\"start-vs-run\" class=\"section level3\"\u003e\r\n\u003ch3\u003eStart Vs Run\u003c/h3\u003e\r\n\u003cp\u003eIn this example, we used the function start to put our thread to work. Another alternative would be the function run . The difference between these two functions gets important, when we are dealing with more than just one thread.\r\nWhen we use the run function to execute our threads, they run serially one after the other. They wait for each other to finish. The start function puts all of them to work simultaneously.\r\nThe following example demonstrates this difference quite well.\u003c/p\u003e\r\n\u003cpre class=\"python\"\u003e\u003ccode\u003eimport threading\r\n\r\ndef function1():\r\n  for x in range ( 1000 ):\r\n  print ( \u0026#39;ONE\u0026#39; )\r\ndef function2():\r\n  for x in range ( 1000 ):\r\n  print ( \u0026#39;TWO\u0026#39; )\r\n  \r\nt1 = threading.Thread( target =function1)\r\n\r\nt2 = threading.Thread( target =function2)\r\n\r\nt1.start()\r\n\r\nt2.start()\u003c/code\u003e\u003c/pre\u003e\r\n\u003cp\u003eWhen you run this script, you will notice that the output alternates between ONEs and TWOs . Now if you use the run function instead of the start function, you will see 1000 times ONE followed by 1000 times TWO . This shows you that the threads are run serially and not in parallel.\u003c/p\u003e\r\n\u003cp\u003eOne more thing that you should know is that the application itself is also the main thread, which continues to run in the background. So while your threads are running, the code of the script will be executed unless you wait for the threads to finish.\u003c/p\u003e\r\n\u003c/div\u003e\r\n\u003cdiv id=\"waiting-for-threads\" class=\"section level3\"\u003e\r\n\u003ch3\u003eWaiting for threads\u003c/h3\u003e\r\n\u003cpre class=\"python\"\u003e\u003ccode\u003eimport threading\r\ndef function():\r\n  for x in range ( 500000 ):\r\n  print ( \u0026#39;HELLO WORLD!\u0026#39; )\r\n  t1 = threading.Thread( target =function)\r\nt1.start()\r\nprint ( \u0026#39;THIS IS THE END!\u0026#39; )\u003c/code\u003e\u003c/pre\u003e\r\n\u003cp\u003eIf you execute this code, you will start printing the text “HELLO WORLD!” 500,000 times. But what you will notice is that the last print statement gets executed immediately after our thread starts and not after it ends.\u003c/p\u003e\r\n\u003cpre class=\"python\"\u003e\u003ccode\u003et1 = threading.Thread( target =function)\r\nt1.start()\r\nt1.join()\r\nprint ( \u0026#39;THIS IS THE END!\u0026#39; )\u003c/code\u003e\u003c/pre\u003e\r\n\u003cp\u003eBy using the join function here, we wait for the thread to finish before we move on with the last print statement. If we want to set a maximum time that we want to wait, we just pass the number of seconds as a parameter.\u003c/p\u003e\r\n\u003cpre class=\"python\"\u003e\u003ccode\u003et1 = threading.Thread( target =function)\r\nt1.start()\r\nt1.join( 5 )\r\nprint ( \u0026#39;THIS IS THE END!\u0026#39; )\u003c/code\u003e\u003c/pre\u003e\r\n\u003cp\u003eIn this case, we will wait for the thread to finish but only a maximum of five seconds. After this time has passed we will proceed with the code.\r\nNotice that we are only waiting for this particular thread. If we would have other threads running at the same time, we would have to call the join function on each of them in order to wait for all of them.\u003c/p\u003e\r\n\u003c/div\u003e\r\n\u003cdiv id=\"thread-classes\" class=\"section level3\"\u003e\r\n\u003ch3\u003eThread classes\u003c/h3\u003e\r\n\u003cp\u003eAnother way to build our threads is to create a class that inherits the Thread class. We can then modify the run function and implement our functionality. The start function is also using the code from the run function so we don’t have to worry about that.\u003c/p\u003e\r\n\u003cpre class=\"python\"\u003e\u003ccode\u003eimport threading\r\nclass MyThread(threading.Thread):\r\n  def __init__ ( self , message):\r\n    threading.Thread. __init__ ( self )\r\n    self .message = message\r\n    \r\n  def run( self ):\r\n    for x in range ( 100 ):\r\n    print ( self .message)\r\n    \r\nmt1 = MyThread( \u0026#39;This is my thread message!\u0026#39; )\r\nmt1.start()\u003c/code\u003e\u003c/pre\u003e\r\n\u003cp\u003eIt is basically the same but it offers more modularity and structure, if you want to use attributes and additional functions.\u003c/p\u003e\r\n\u003c/div\u003e\r\n\u003cdiv id=\"synchronizing-threads\" class=\"section level3\"\u003e\r\n\u003ch3\u003eSynchronizing Threads\u003c/h3\u003e\r\n\u003cp\u003eSometimes you are going to have multiple threads running that all try to access the same resource. This may lead to inconsistencies and problems. In order to prevent such things there is a concept called locking . Basically, one thread is locking all of the other threads and they can only continue to work when the lock is removed.\u003c/p\u003e\r\n\u003cp\u003eI came up with the following quite trivial example. It seems a bit abstract but you can still get the concept here.\u003c/p\u003e\r\n\u003cpre class=\"python\"\u003e\u003ccode\u003eimport threading\r\nimport time\r\nx = 8192\r\ndef halve():\r\n  global x\r\n  while (x \u0026gt; 1 ):\r\n    x /= 2\r\n    print (x)\r\n    time.sleep( 1 )\r\n  print ( \u0026#39;END!\u0026#39; )\r\n  \r\ndef double():\r\n  global x\r\n  while (x \u0026lt; 16384 ):\r\n    x *= 2\r\n    print (x)\r\n    time.sleep( 1 )\r\n  print ( \u0026#39;END!\u0026#39; )\r\nt1 = threading.Thread( target =halve)\r\nt2 = threading.Thread( target =double)\r\nt1.start()\r\nt2.start()\u003c/code\u003e\u003c/pre\u003e\r\n\u003cp\u003eHere we have two functions and the variable x that starts at the value 8192 . The first function halves the number as long as it is greater than one, whereas the second function doubles the number as long as it is less than 16384 .\u003c/p\u003e\r\n\u003cp\u003eAlso, I’ve imported the module time in order to use the function sleep . This function puts the thread to sleep for a couple of seconds (in this case one second). So it pauses. We just do that, so that we can better track what’s happening.\r\nWhen we now start two threads with these target functions, we will see that the script won’t come to an end. The halve function will constantly decrease the number and the double function will constantly increase it.\u003c/p\u003e\r\n\u003cpre class=\"python\"\u003e\u003ccode\u003eimport threading\r\nimport time\r\nx = 8192\r\nlock = threading.Lock()\r\ndef halve():\r\n  global x, lock\r\n  lock.acquire()\r\n  while (x \u0026gt; 1 ):\r\n    x /= 2\r\n    print (x)\r\n    time.sleep( 1 )\r\n  print ( \u0026#39;END!\u0026#39; )\r\n  lock.release()\r\n  \r\ndef double():\r\n  global x, lock\r\n  lock.acquire()\r\n  while (x \u0026lt; 16384 ):\r\n    x *= 2\r\n    print (x)\r\n    time.sleep( 1 )\r\n  print ( \u0026#39;END!\u0026#39; )\r\n  lock.release()\r\nt1 = threading.Thread( target =halve)\r\nt2 = threading.Thread( target =double)\r\nt1.start()\r\nt2.start()\u003c/code\u003e\u003c/pre\u003e\r\n\u003cp\u003eSo here we added a couple of elements. First of all we defined a Lock object. It is part of the threading module and we need this object in order to manage the locking.\r\nNow, when we want to try to lock the resource, we use the function acquire . If the lock was already locked by someone else, we wait until it is released again before we continue with the code. However, if the lock is free, we lock it ourselves and release it at the end using the release function.\r\nHere, we start both functions with a locking attempt. The first function that gets executed will lock the other function and finish its loop. After that it will release the lock and the other function can do the same.\r\nSo the number will be halved until it reaches the number one and then it will be doubled until it reaches the number 16384 .\u003c/p\u003e\r\n\u003c/div\u003e\r\n\u003c/div\u003e\r\n\u003c/div\u003e\r\n\u003cdiv id=\"semaphores\" class=\"section level1\"\u003e\r\n\u003ch1\u003eSemaphores\u003c/h1\u003e\r\n\u003cp\u003eSometimes we don’t want to completely lock a resource but just limit it to a certain amount of threads or accesses. In this case, we can use so-called semaphores .\r\nTo demonstrate this concept, we will look at another very abstract example.\u003c/p\u003e\r\n\u003cpre class=\"python\"\u003e\u003ccode\u003eimport threading\r\nimport time\r\nsemaphore = threading.BoundedSemaphore( value = 5 )\r\ndef access(thread_number):\r\n  print ( \u0026#39;{}: Trying access...\u0026#39;.format(thread_number))\r\n  semaphore.acquire()\r\n  print ( \u0026#39;{}: Access granted!\u0026#39;.format(thread_number))\r\n  print ( \u0026#39;{}: Waiting 5 seconds...\u0026#39;.format(thread_number))\r\n  time.sleep( 5 )\r\n  semaphore.release()\r\n  print ( \u0026#39;{}: Releasing!\u0026#39;.format(thread_number))\r\n  \r\nfor thread_number in range ( 10 ):\r\n  t = threading.Thread( target =access,args =(thread_number,))\r\nt.start()\u003c/code\u003e\u003c/pre\u003e\r\n\u003cp\u003eWe first use the BoundedSemaphore class to create our semaphore object. The parameter value determines how many parallel accesses we allow. In this case, we choose five.\r\nWith our access function, we try to access the semaphore. Here, this is also done with the acquire function. If there are less than five threads utilizing the semaphore, we can acquire it and continue with the code. But when it’s full, we need to wait until some other thread frees up one space.\r\nWhen we run this code, you will see that the first five threads will immediately run the code, whereas the remaining five threads will need to wait five seconds until the first threads release the semaphore.\r\nThis process makes a lot of sense when we have limited resources or limited computational power in a system and we want to limit the access to it.\u003c/p\u003e\r\n\u003cp\u003eWith events we can manage our threads even better. We can pause a thread and wait for a certain event to happen, in order to continue it.\u003c/p\u003e\r\n\u003cpre class=\"python\"\u003e\u003ccode\u003eimport threading\r\nevent = threading.Event()\r\ndef function():\r\n  print ( \u0026#39;Waiting for event...\u0026#39; )\r\n  event.wait()\r\n  print ( \u0026#39;Continuing!\u0026#39; )\r\n  \r\nthread = threading.Thread( target =function)\r\nthread.start()\r\n\r\nx = input ( \u0026#39;Trigger event?\u0026#39; )\r\nif (x == \u0026#39;yes\u0026#39; ):\r\n  event.set()\u003c/code\u003e\u003c/pre\u003e\r\n\u003cp\u003eTo define an event we use the Event class of the threading module. Now we define our function which waits for our event. This is done with the wait function. So we start the thread and it waits.\r\nThen we ask the user, if he wants to trigger the event. If the answer is yes, we trigger it by using the set function. Once the event is triggered, our function no longer waits and continues with the code.\u003c/p\u003e\r\n\u003cdiv id=\"daemon-threads\" class=\"section level2\"\u003e\r\n\u003ch2\u003eDaemon Threads\u003c/h2\u003e\r\n\u003cp\u003eSo-called daemon threads are a special kind of thread that runs in the background. This means that the program can be terminated even if this thread is still running. Daemon threads are typically used for background tasks like synchronizing, loading or cleaning up files that are not needed anymore. We define a thread as a daemon by setting the respective parameter in the constructor for Thread to True .\u003c/p\u003e\r\n\u003cpre class=\"python\"\u003e\u003ccode\u003eimport threading\r\nimport time\r\npath = \u0026#39;text.txt\u0026#39;\r\ntext = \u0026#39;\u0026#39;\r\ndef readFile():\r\n  global path, text\r\n  while True :\r\n    with open (path) as file:\r\n    text = file.read()\r\n    time.sleep( 3 )\r\n    \r\ndef printloop():\r\n  global text\r\n  for x in range ( 30 ):\r\n    print (text)\r\n    time.sleep( 1 )\r\n\r\nt1 = threading.Thread( target =readFile, daemon = True )\r\nt2 = threading.Thread( target =printloop)\r\nt1.start()\r\nt2.start()\u003c/code\u003e\u003c/pre\u003e\r\n\u003cp\u003eSo, here we have two functions. The first one constantly reads in the text from a file and saves it into the text variable. This is done in an interval of three seconds. The second one prints out the content of text every second but only 30 times.\u003c/p\u003e\r\n\u003cp\u003eAs you can see, we start the readFile function in a daemon thread and the printloop function in an ordinary thread. So when we run this script and change the content of the text.txt file while it is running, we will see that it prints the actual content all the time. Of course, we first need to create that file manually.\u003c/p\u003e\r\n\u003cp\u003eAfter it printed the content 30 times however, the whole script will stop, even though the daemon thread is still reading in the files. Since the ordinary threads are all finished, the program ends and the daemon thread just gets terminated With locking we can now let one function finish before the next function starts. Of course, in this example this is not very useful but we can do the same thing in much more complex situations.\u003c/p\u003e\r\n\u003c/div\u003e\r\n\u003c/div\u003e"
}
</script>

  

<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-155379268-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>  


<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-T5KFS4C');</script>

</head>

  <body>
    
    
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-T5KFS4C"
    height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    
      
    

<header id="site-header">
  <nav id="site-nav">
    <h1 class="nav-title">
      <a href="/" class="nav">
        
          Blog
        
      </a>
    </h1>
    <menu id="site-nav-menu" class="flyout-menu menu">
      
        
          
          <a href="/" class="nav link"><i class='fa fa-home'></i> Home</a>
        
      
        
          
          <a href="/about/" class="nav link"><i class='far fa-id-card'></i> About</a>
        
      
        
          
          <a href="/blog/" class="nav link"><i class='far fa-newspaper'></i> Blog</a>
        
      
        
          
          <a href="/categories/" class="nav link"><i class='fas fa-sitemap'></i> Categories</a>
        
      
        
          
          <a href="/contact/" class="nav link"><i class='far fa-envelope'></i> Contact</a>
        
      
      <a href="#share-menu" class="nav link share-toggle"><i class="fas fa-share-alt">&nbsp;</i>Share</a>
      <a href="#search-input" class="nav link search-toggle"><i class="fas fa-search">&nbsp;</i>Search</a>
    </menu>
    <a href="#search-input" class="nav search-toggle"><i class="fas fa-search fa-2x">&nbsp;</i></a>
    <a href="#share-menu" class="nav share-toggle"><i class="fas fa-share-alt fa-2x">&nbsp;</i></a>
    <a href="#lang-menu" class="nav lang-toggle" lang="en">en</a>
    <a href="#site-nav" class="nav nav-toggle"><i class="fas fa-bars fa-2x"></i></a>
  </nav>
  <menu id="search" class="menu"><input id="search-input" class="search-input menu"></input><div id="search-results" class="search-results menu"></div></menu>
  <menu id="lang-menu" class="flyout-menu menu">
  <a href="#" lang="en" class="nav link active">English (en)</a>
  
    
      
    
  
</menu>

  
    <menu id="share-menu" class="flyout-menu menu">
      <h1>Share Post</h1>
      




  
    
    <a href="//twitter.com/share?text=Python%20-%20Multithreading&amp;url=https%3a%2f%2flaxmikants.github.io%2fblog%2fpython-multithreading%2f" target="_blank" rel="noopener" class="nav share-btn twitter">
        <p>Twitter</p>
      </a>
  

  
      <a href="//www.facebook.com/sharer/sharer.php?u=https%3a%2f%2flaxmikants.github.io%2fblog%2fpython-multithreading%2f" target="_blank" rel="noopener" class="nav share-btn facebook">
        <p>Facebook</p>
        </a>
  

  
        <a href="//www.linkedin.com/shareArticle?url=https%3a%2f%2flaxmikants.github.io%2fblog%2fpython-multithreading%2f&amp;title=Python%20-%20Multithreading" target="_blank" rel="noopener" class="nav share-btn linkedin">
            <p>LinkedIn</p>
          </a>
  


    </menu>
  
</header>

    <div id="wrapper">
      <section id="site-intro" >
  
  <header>
    <h1>Data Science Posts and Resources</h1>
  </header>
  <main>
    <p>Articles on Data Science</p>
  </main>
  
    <footer>
      <ul class="socnet-icons">
        

        <li><a href="//github.com/laxmikants" target="_blank" rel="noopener" title="GitHub" class="fab fa-github"></a></li>











<li><a href="//linkedin.com/in/laxmikantsoni09" target="_blank" rel="noopener" title="LinkedIn" class="fab fa-linkedin"></a></li>




<li><a href="//facebook.com/laxmikantsoni09" target="_blank" rel="noopener" title="Facebook" class="fab fa-facebook"></a></li>










<li><a href="//twitter.com/laxmikantsoni09" target="_blank" rel="noopener" title="Twitter" class="fab fa-twitter"></a></li>













      </ul>
    </footer>
  
</section>

      <main id="site-main">
        
  <article class="post">
    <header>
  <div class="title">
    
      <h2><a href="/blog/python-multithreading/">Python - Multithreading</a></h2>
    
    
      <p>Introduction to Python Multithreading</p>
    
  </div>
  <div class="meta">
    <time datetime="2019-01-19 00:00:00 &#43;0000 UTC">January 19, 2019</time>
    <p>Laxmi K Soni</p>
    <p>11-Minute Read</p>
  </div>
</header>

    <div id="socnet-share">
      




  
    
    <a href="//twitter.com/share?text=Python%20-%20Multithreading&amp;url=https%3a%2f%2flaxmikants.github.io%2fblog%2fpython-multithreading%2f" target="_blank" rel="noopener" class="nav share-btn twitter">
        <p>Twitter</p>
      </a>
  

  
      <a href="//www.facebook.com/sharer/sharer.php?u=https%3a%2f%2flaxmikants.github.io%2fblog%2fpython-multithreading%2f" target="_blank" rel="noopener" class="nav share-btn facebook">
        <p>Facebook</p>
        </a>
  

  
        <a href="//www.linkedin.com/shareArticle?url=https%3a%2f%2flaxmikants.github.io%2fblog%2fpython-multithreading%2f&amp;title=Python%20-%20Multithreading" target="_blank" rel="noopener" class="nav share-btn linkedin">
            <p>LinkedIn</p>
          </a>
  


    </div>
    <div class="content">
      <a href="/blog/python-multithreading/" class="image" style="--bg-image: url('https://laxmikants.github.io/img/main/Python-Thread-21.jpg');">
    <img src="https://laxmikants.github.io/img/main/Python-Thread-21.jpg" alt="">
  </a>
      
<script src="/rmarkdown-libs/header-attrs/header-attrs.js"></script>
<link href="/rmarkdown-libs/anchor-sections/anchor-sections.css" rel="stylesheet" />
<script src="/rmarkdown-libs/anchor-sections/anchor-sections.js"></script>

<div id="TOC">
<ul>
<li><a href="#multithreading">Multithreading</a>
<ul>
<li><a href="#how-a-thread-works">How a thread works</a>
<ul>
<li><a href="#how-to-start-thread">how to start thread</a></li>
<li><a href="#start-vs-run">Start Vs Run</a></li>
<li><a href="#waiting-for-threads">Waiting for threads</a></li>
<li><a href="#thread-classes">Thread classes</a></li>
<li><a href="#synchronizing-threads">Synchronizing Threads</a></li>
</ul></li>
</ul></li>
<li><a href="#semaphores">Semaphores</a>
<ul>
<li><a href="#daemon-threads">Daemon Threads</a></li>
</ul></li>
</ul>
</div>

<hr>
<div id="multithreading" class="section level1">
<h1>Multithreading</h1>
<p>Threads are lightweight processes that perform certain actions in a program and they are part of a process themselves. These threads can work in parallel with each other in the same way as two individual applications can.</p>
<p>Since threads in the same process share the memory space for the variables and the data, they can exchange information and communicate efficiently. Also, threads need fewer resources than processes. That’s why they’re often called lightweight processes.</p>
<div id="how-a-thread-works" class="section level2">
<h2>How a thread works</h2>
<p>A thread has a beginning or a start, a working sequence and an end. But it can also be stopped or put on hold at any time. The latter is also called sleep .
There are two types of threads: Kernel Threads and User Threads . Kernel threads are part of the operating system, whereas user threads are managed by the programmer. That’s why we will focus on user threads in this book.</p>
<p>In Python, a thread is a class that we can create instances of. Each of these instances then represents an individual thread which we can start, pause or stop. They are all independent from each other and they can perform different operations at the same time.</p>
<p>For example, in a video game, one thread could be rendering all the graphics, while another thread processes the keyboard and mouse inputs. It would be unthinkable to serially perform these tasks one after the other.</p>
<div id="how-to-start-thread" class="section level3">
<h3>how to start thread</h3>
<p>In order to work with threads in Python, we will need to import the respective library threading .</p>
<pre class="python"><code>import threading</code></pre>
<p>Then, we need to define our target function. This will be the function that contains the code that our thread shall be executing. Let’s just keep it simple for the beginning and write a hello world function.</p>
<pre class="python"><code>import threading
def hello():
  print ( &#39;Hello World!&#39; )
  t1 = threading.Thread( target =hello)
  t1.start()</code></pre>
<p>After we have defined the function, we create our first thread. For this, we use the class Thread of the imported threading module. As a parameter, we specify the target to be the hello function. Notice that we don’t put parentheses after our function name here, since we are not calling it but just referring to it. By using the start method we put our thread to work and it executes our function.</p>
</div>
<div id="start-vs-run" class="section level3">
<h3>Start Vs Run</h3>
<p>In this example, we used the function start to put our thread to work. Another alternative would be the function run . The difference between these two functions gets important, when we are dealing with more than just one thread.
When we use the run function to execute our threads, they run serially one after the other. They wait for each other to finish. The start function puts all of them to work simultaneously.
The following example demonstrates this difference quite well.</p>
<pre class="python"><code>import threading

def function1():
  for x in range ( 1000 ):
  print ( &#39;ONE&#39; )
def function2():
  for x in range ( 1000 ):
  print ( &#39;TWO&#39; )
  
t1 = threading.Thread( target =function1)

t2 = threading.Thread( target =function2)

t1.start()

t2.start()</code></pre>
<p>When you run this script, you will notice that the output alternates between ONEs and TWOs . Now if you use the run function instead of the start function, you will see 1000 times ONE followed by 1000 times TWO . This shows you that the threads are run serially and not in parallel.</p>
<p>One more thing that you should know is that the application itself is also the main thread, which continues to run in the background. So while your threads are running, the code of the script will be executed unless you wait for the threads to finish.</p>
</div>
<div id="waiting-for-threads" class="section level3">
<h3>Waiting for threads</h3>
<pre class="python"><code>import threading
def function():
  for x in range ( 500000 ):
  print ( &#39;HELLO WORLD!&#39; )
  t1 = threading.Thread( target =function)
t1.start()
print ( &#39;THIS IS THE END!&#39; )</code></pre>
<p>If you execute this code, you will start printing the text “HELLO WORLD!” 500,000 times. But what you will notice is that the last print statement gets executed immediately after our thread starts and not after it ends.</p>
<pre class="python"><code>t1 = threading.Thread( target =function)
t1.start()
t1.join()
print ( &#39;THIS IS THE END!&#39; )</code></pre>
<p>By using the join function here, we wait for the thread to finish before we move on with the last print statement. If we want to set a maximum time that we want to wait, we just pass the number of seconds as a parameter.</p>
<pre class="python"><code>t1 = threading.Thread( target =function)
t1.start()
t1.join( 5 )
print ( &#39;THIS IS THE END!&#39; )</code></pre>
<p>In this case, we will wait for the thread to finish but only a maximum of five seconds. After this time has passed we will proceed with the code.
Notice that we are only waiting for this particular thread. If we would have other threads running at the same time, we would have to call the join function on each of them in order to wait for all of them.</p>
</div>
<div id="thread-classes" class="section level3">
<h3>Thread classes</h3>
<p>Another way to build our threads is to create a class that inherits the Thread class. We can then modify the run function and implement our functionality. The start function is also using the code from the run function so we don’t have to worry about that.</p>
<pre class="python"><code>import threading
class MyThread(threading.Thread):
  def __init__ ( self , message):
    threading.Thread. __init__ ( self )
    self .message = message
    
  def run( self ):
    for x in range ( 100 ):
    print ( self .message)
    
mt1 = MyThread( &#39;This is my thread message!&#39; )
mt1.start()</code></pre>
<p>It is basically the same but it offers more modularity and structure, if you want to use attributes and additional functions.</p>
</div>
<div id="synchronizing-threads" class="section level3">
<h3>Synchronizing Threads</h3>
<p>Sometimes you are going to have multiple threads running that all try to access the same resource. This may lead to inconsistencies and problems. In order to prevent such things there is a concept called locking . Basically, one thread is locking all of the other threads and they can only continue to work when the lock is removed.</p>
<p>I came up with the following quite trivial example. It seems a bit abstract but you can still get the concept here.</p>
<pre class="python"><code>import threading
import time
x = 8192
def halve():
  global x
  while (x &gt; 1 ):
    x /= 2
    print (x)
    time.sleep( 1 )
  print ( &#39;END!&#39; )
  
def double():
  global x
  while (x &lt; 16384 ):
    x *= 2
    print (x)
    time.sleep( 1 )
  print ( &#39;END!&#39; )
t1 = threading.Thread( target =halve)
t2 = threading.Thread( target =double)
t1.start()
t2.start()</code></pre>
<p>Here we have two functions and the variable x that starts at the value 8192 . The first function halves the number as long as it is greater than one, whereas the second function doubles the number as long as it is less than 16384 .</p>
<p>Also, I’ve imported the module time in order to use the function sleep . This function puts the thread to sleep for a couple of seconds (in this case one second). So it pauses. We just do that, so that we can better track what’s happening.
When we now start two threads with these target functions, we will see that the script won’t come to an end. The halve function will constantly decrease the number and the double function will constantly increase it.</p>
<pre class="python"><code>import threading
import time
x = 8192
lock = threading.Lock()
def halve():
  global x, lock
  lock.acquire()
  while (x &gt; 1 ):
    x /= 2
    print (x)
    time.sleep( 1 )
  print ( &#39;END!&#39; )
  lock.release()
  
def double():
  global x, lock
  lock.acquire()
  while (x &lt; 16384 ):
    x *= 2
    print (x)
    time.sleep( 1 )
  print ( &#39;END!&#39; )
  lock.release()
t1 = threading.Thread( target =halve)
t2 = threading.Thread( target =double)
t1.start()
t2.start()</code></pre>
<p>So here we added a couple of elements. First of all we defined a Lock object. It is part of the threading module and we need this object in order to manage the locking.
Now, when we want to try to lock the resource, we use the function acquire . If the lock was already locked by someone else, we wait until it is released again before we continue with the code. However, if the lock is free, we lock it ourselves and release it at the end using the release function.
Here, we start both functions with a locking attempt. The first function that gets executed will lock the other function and finish its loop. After that it will release the lock and the other function can do the same.
So the number will be halved until it reaches the number one and then it will be doubled until it reaches the number 16384 .</p>
</div>
</div>
</div>
<div id="semaphores" class="section level1">
<h1>Semaphores</h1>
<p>Sometimes we don’t want to completely lock a resource but just limit it to a certain amount of threads or accesses. In this case, we can use so-called semaphores .
To demonstrate this concept, we will look at another very abstract example.</p>
<pre class="python"><code>import threading
import time
semaphore = threading.BoundedSemaphore( value = 5 )
def access(thread_number):
  print ( &#39;{}: Trying access...&#39;.format(thread_number))
  semaphore.acquire()
  print ( &#39;{}: Access granted!&#39;.format(thread_number))
  print ( &#39;{}: Waiting 5 seconds...&#39;.format(thread_number))
  time.sleep( 5 )
  semaphore.release()
  print ( &#39;{}: Releasing!&#39;.format(thread_number))
  
for thread_number in range ( 10 ):
  t = threading.Thread( target =access,args =(thread_number,))
t.start()</code></pre>
<p>We first use the BoundedSemaphore class to create our semaphore object. The parameter value determines how many parallel accesses we allow. In this case, we choose five.
With our access function, we try to access the semaphore. Here, this is also done with the acquire function. If there are less than five threads utilizing the semaphore, we can acquire it and continue with the code. But when it’s full, we need to wait until some other thread frees up one space.
When we run this code, you will see that the first five threads will immediately run the code, whereas the remaining five threads will need to wait five seconds until the first threads release the semaphore.
This process makes a lot of sense when we have limited resources or limited computational power in a system and we want to limit the access to it.</p>
<p>With events we can manage our threads even better. We can pause a thread and wait for a certain event to happen, in order to continue it.</p>
<pre class="python"><code>import threading
event = threading.Event()
def function():
  print ( &#39;Waiting for event...&#39; )
  event.wait()
  print ( &#39;Continuing!&#39; )
  
thread = threading.Thread( target =function)
thread.start()

x = input ( &#39;Trigger event?&#39; )
if (x == &#39;yes&#39; ):
  event.set()</code></pre>
<p>To define an event we use the Event class of the threading module. Now we define our function which waits for our event. This is done with the wait function. So we start the thread and it waits.
Then we ask the user, if he wants to trigger the event. If the answer is yes, we trigger it by using the set function. Once the event is triggered, our function no longer waits and continues with the code.</p>
<div id="daemon-threads" class="section level2">
<h2>Daemon Threads</h2>
<p>So-called daemon threads are a special kind of thread that runs in the background. This means that the program can be terminated even if this thread is still running. Daemon threads are typically used for background tasks like synchronizing, loading or cleaning up files that are not needed anymore. We define a thread as a daemon by setting the respective parameter in the constructor for Thread to True .</p>
<pre class="python"><code>import threading
import time
path = &#39;text.txt&#39;
text = &#39;&#39;
def readFile():
  global path, text
  while True :
    with open (path) as file:
    text = file.read()
    time.sleep( 3 )
    
def printloop():
  global text
  for x in range ( 30 ):
    print (text)
    time.sleep( 1 )

t1 = threading.Thread( target =readFile, daemon = True )
t2 = threading.Thread( target =printloop)
t1.start()
t2.start()</code></pre>
<p>So, here we have two functions. The first one constantly reads in the text from a file and saves it into the text variable. This is done in an interval of three seconds. The second one prints out the content of text every second but only 30 times.</p>
<p>As you can see, we start the readFile function in a daemon thread and the printloop function in an ordinary thread. So when we run this script and change the content of the text.txt file while it is running, we will see that it prints the actual content all the time. Of course, we first need to create that file manually.</p>
<p>After it printed the content 30 times however, the whole script will stop, even though the daemon thread is still reading in the files. Since the ordinary threads are all finished, the program ends and the daemon thread just gets terminated With locking we can now let one function finish before the next function starts. Of course, in this example this is not very useful but we can do the same thing in much more complex situations.</p>
</div>
</div>

    </div>
    <footer>
      <div class="stats">
  <ul class="categories">
    
      
        
          <li><a class="article-terms-link" href="/categories/python/">Python</a></li>
        
      
    
  </ul>
  <ul class="tags">
    
      
        
          <li><a class="article-terms-link" href="/tags/python/">Python</a></li>
        
      
    
  </ul>
</div>

    </footer>
  </article>
  
    

  <article class="post">
    
    <div>
      <h2 id="say-something">Say Something</h2>
        <form id="comment-form" class="new-comment" method="POST">
          
          <h3 class='reply-notice hidden'>
            <span class='reply-name'></span>
          </h3>

          
          <input type="hidden" name="options[entryId]" value="3065303f8ad0bfcc66061ae01157274f">
          <input type='hidden' name='fields[replyThread]' value=''>
          <input type='hidden' name='fields[replyID]' value=''>
          <input type='hidden' name='fields[replyName]' value=''>

          
          <input required name='fields[name]' type='text' placeholder='Your Name'>
          <input name='fields[website]' type='text' placeholder='Your Website'>
          <input required name='fields[email]' type='email' placeholder='Your Email'>
          <textarea required name='fields[body]' placeholder='Your Message' rows='10'></textarea>

          
          

          
          <div class='submit-notice'>
            <strong class='submit-notice-text submit-success hidden'>Thanks for your comment! It will be shown on the site once it has been approved.</strong>
            <strong class='submit-notice-text submit-failed hidden'>Sorry, there was an error with your submission. Please make sure all required fields have been completed and try again.</strong>
          </div>

          
          <input type='submit' value='Submit' class='button'>
          <input type='submit' value='Submitted' class='hidden button' disabled>
          <input type='reset' value='Reset' class='button'>
        </form>
    </div>

    
    <div>
      <h2>Comments</h2><p>Nothing yet.</p>
      
    </div>
  </article>


  
  <div class="pagination">
    
      <a href="/blog/python-queues/" class="button left"><span>Python - Queues</span></a>
    
    
      <a href="/blog/python-basics-2/" class="button right"><span>Python - Classes and Objects</span></a>
    
  </div>

      </main>
      <section id="site-sidebar">
  
    <section id="recent-posts">
      <header>
        <h1>Recent Posts</h1>
      </header>
      
      <article class="mini-post">
          <a href="/blog/convolutional-neural-networks/" class="image" style="--bg-image: url('https://laxmikants.github.io/img/main/cnn-neural-network.jpg');">
    <img src="https://laxmikants.github.io/img/main/cnn-neural-network.jpg" alt="CNN Neural Networks">
  </a>
        <header>
          <h2><a href="/blog/convolutional-neural-networks/">Convolutional Neural Networks</a></h2>
          <time class="published" datetime="2021-01-03 00:00:00 &#43;0000 UTC">January 3, 2021</time>
        </header>
      </article>
      
      <article class="mini-post">
          <a href="/blog/neural-network-using-make-moons-dataset/" class="image" style="--bg-image: url('https://laxmikants.github.io/img/main/nn_makemoons_dataset.jpg');">
    <img src="https://laxmikants.github.io/img/main/nn_makemoons_dataset.jpg" alt="">
  </a>
        <header>
          <h2><a href="/blog/neural-network-using-make-moons-dataset/">Neural Network using Make Moons dataset</a></h2>
          <time class="published" datetime="2020-12-10 00:00:00 &#43;0000 UTC">December 10, 2020</time>
        </header>
      </article>
      
      <article class="mini-post">
          <a href="/blog/single-layer-perceptron/" class="image" style="--bg-image: url('https://laxmikants.github.io/img/main/Single_Layer_Perceptron.jpg');">
    <img src="https://laxmikants.github.io/img/main/Single_Layer_Perceptron.jpg" alt="">
  </a>
        <header>
          <h2><a href="/blog/single-layer-perceptron/">Single Layer Perceptron</a></h2>
          <time class="published" datetime="2020-12-10 00:00:00 &#43;0000 UTC">December 10, 2020</time>
        </header>
      </article>
      
      
        <footer>
          <a href="/blog/" class="button">See More</a>
        </footer>
      

      
    </section>
  


  
    
      <section id="categories">
        <header>
          <h1><a href="/categories">Categories</a></h1>
        </header>
        <ul>
          
          
          <li>
              <a href="/categories/python/">python<span class="count">14</span></a>
          
          <li>
              <a href="/categories/linear-regression/">linear-regression<span class="count">2</span></a>
          
          <li>
              <a href="/categories/logistic-regression/">logistic-regression<span class="count">2</span></a>
          
          <li>
              <a href="/categories/big-data/">big-data<span class="count">1</span></a>
          
          <li>
              <a href="/categories/bigdata/">bigdata<span class="count">1</span></a>
          
          <li>
              <a href="/categories/classification/">classification<span class="count">1</span></a>
          
          <li>
              <a href="/categories/clustering/">clustering<span class="count">1</span></a>
          
          <li>
              <a href="/categories/convolutional-neural-networks/">convolutional-neural-networks<span class="count">1</span></a>
          
          <li>
              <a href="/categories/data-science/">data-science<span class="count">1</span></a>
          
          <li>
              <a href="/categories/decision-trees/">decision-trees<span class="count">1</span></a>
          
          <li>
              <a href="/categories/eda/">eda<span class="count">1</span></a>
          
          <li>
              <a href="/categories/exploring-dataset/">exploring-dataset<span class="count">1</span></a>
          
          <li>
              <a href="/categories/frequency-tables/">frequency-tables<span class="count">1</span></a>
          
          <li>
              <a href="/categories/hadoop/">hadoop<span class="count">1</span></a>
          
          <li>
              <a href="/categories/k-nearest-neighbours/">k-nearest-neighbours<span class="count">1</span></a>
          
          <li>
              <a href="/categories/machine-learning/">machine-learning<span class="count">1</span></a>
          
          <li>
              <a href="/categories/natural-language-processing/">natural-language-processing<span class="count">1</span></a>
          
          <li>
              <a href="/categories/neural-network/">neural-network<span class="count">1</span></a>
          
          <li>
              <a href="/categories/neural-networks/">neural-networks<span class="count">1</span></a>
          
          <li>
              <a href="/categories/numeric-data/">numeric-data<span class="count">1</span></a>
          
          <li>
              <a href="/categories/pandas/">pandas<span class="count">1</span></a>
          
          <li>
              <a href="/categories/react-native/">react-native<span class="count">1</span></a>
          
          <li>
              <a href="/categories/reactjs/">reactjs<span class="count">1</span></a>
          
          <li>
              <a href="/categories/single-layer-perceptron/">single-layer-perceptron<span class="count">1</span></a>
          
          <li>
              <a href="/categories/stock-market/">stock-market<span class="count">1</span></a>
          
          <li>
              <a href="/categories/support-vector-machines/">support-vector-machines<span class="count">1</span></a>
          
          <li>
              <a href="/categories/text-analytics/">text-analytics<span class="count">1</span></a>
          
          <li>
              <a href="/categories/time-series/">time-series<span class="count">1</span></a>
          
          <li>
              <a href="/categories/web-scrapping/">web-scrapping<span class="count">1</span></a>
          
          </li>
        </ul>
      </section>
    
  



  
    <section id="mini-bio">
      <header>
        <h1>About</h1>
      </header>
      <p>about</p>
      <footer>
        <a href="/about" class="button">Learn More</a>
      </footer>
    </section>
  
</section>

      <footer id="site-footer">
  
  
      <ul class="socnet-icons">
        

        <li><a href="//github.com/laxmikants" target="_blank" rel="noopener" title="GitHub" class="fab fa-github"></a></li>











<li><a href="//linkedin.com/in/laxmikantsoni09" target="_blank" rel="noopener" title="LinkedIn" class="fab fa-linkedin"></a></li>




<li><a href="//facebook.com/laxmikantsoni09" target="_blank" rel="noopener" title="Facebook" class="fab fa-facebook"></a></li>










<li><a href="//twitter.com/laxmikantsoni09" target="_blank" rel="noopener" title="Twitter" class="fab fa-twitter"></a></li>













      </ul>
  
  <p class="copyright">
    © 2021 Data Science Posts and Resources
      <br>
  </p>
</footer>

      <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.2/highlight.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.2/languages/python.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script><script src="//code.jquery.com/jquery-3.5.1.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.js"></script>
    <script src="//unpkg.com/lunr/lunr.js"></script><script src="/js/bundlecdn.min.daca826145adfcf5004b4b16d74010eff217a0382fad56b874f5630927a20c4e.js" integrity="sha256-2sqCYUWt/PUAS0sW10AQ7/IXoDgvrVa4dPVjCSeiDE4="></script>
    <script src="/js/add-on.js"></script>
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-155379268-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

    </div>
  </body>
  
</html>
