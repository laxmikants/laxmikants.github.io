[{
    "title": "À propos de",
    "date": "",
    "description": "Hugo, le framework le plus rapide au monde pour la création de sites Web",
    "body": "Écrit dans Go, Hugo est un générateur de site statique open source disponible sous la [Apache License 2.0.] (Https://github.com/gohugoio/hugo/blob/master/LICENSE) Hugo prend en charge les types de fichiers de données TOML, YAML et JSON , Markdown et fichiers de contenu HTML et utilise des shortcodes pour ajouter du contenu riche. Les autres fonctionnalités notables sont les taxonomies, le mode multilingue, le traitement d\u0026rsquo;image, les formats de sortie personnalisés, la minification HTML / CSS / JS et la prise en charge des flux de travail Sass SCSS.\nHugo utilise une variété de projets open source, notamment:\n https://github.com/yuin/goldmark https://github.com/alecthomas/chroma https://github.com/muesli/smartcrop https://github.com/spf13/cobra https://github.com/spf13/viper  Hugo est idéal pour les blogs, les sites Web d\u0026rsquo;entreprise, les portefeuilles créatifs, les magazines en ligne, les applications d\u0026rsquo;une seule page ou même un site Web avec des milliers de pages.\nHugo est destiné aux personnes qui souhaitent coder manuellement leur propre site Web sans se soucier de la mise en place d\u0026rsquo;exécutions complexes, de dépendances et de bases de données.\nLes sites Web construits avec Hugo sont extrêmement rapides, sécurisés et peuvent être déployés n\u0026rsquo;importe où, y compris AWS, GitHub Pages, Heroku, Netlify et tout autre fournisseur d\u0026rsquo;hébergement.\nEn savoir plus et contribuer sur [GitHub] (https://github.com/gohugoio).\n",
    "ref": "/about/"
  },{
    "title": "Python - Classes and Objects",
    "date": "",
    "description": "Introduction to Python Classes and Objects",
    "body": "\r\rCLASSES AND OBJECTS\rPython is an object-oriented language which means that the code can be divided into individual units, namely objects . Each of these objects is an instance of a so-called class . You can think of the class as some sort of blueprint. For example, the blueprint of a car could be the class and an object would be the actual physical car. So a class has specific attributes and functions but the values vary from object to object.\n\rCREATING CLASSES\rIn Python, we use the keyword class in order to define a new class. Whatever which is indented after the colon belongs to the class.\nclass Car:\rdef __init__ ( self , manufacturer, model, hp):\rself .manufacturer = manufacturer\rself .model = model\rself .hp = hp\rAfter the class keyword, we put the class name. In this example, this is Car .\n\rCONSTRUCTOR\rWhat we find first in this case, is a special function called init . This is the so-called constructor. Every time we create an instance or an object of our class, we use this constructor. As you can see, it accepts a couple of parameters. The first one is the parameter self and it is mandatory. Every function of the class needs to have at least this parameter.\rThe other parameters are just our custom attributes. In this case, we have chosen the manufacturer, the model and the horse power (hp).\rWhen we write self.attribute , we refer to the actual attribute of the respective object. We then assign the value of the parameters to it.\n\rADDING FUNCTIONS\rWe can simply create and add functions to our class that perform certain actions. These functions can also access the attributes of the class.\nclass Car:\rdef __init__ ( self , manufacturer, model, hp):\rself .manufacturer = manufacturer\rself .model = model\rself .hp = hp\rdef print_info( self ):\rprint ( \u0026#39;Manufacturer: {}, Model: {}, HP; {}\u0026#39;.format( self .manufacturer, self.model,self.hp))\rHere we have the function print_info that prints out information about the attributes of the respective object. Notice that we also need the parameter self here.\n\rCLASS VARIABLES\rIn the following code, you can see that we can use one and the same variable across all the objects of the class, when it is defined without referring to self .\nclass Car:\ramount_cars = 0\rdef __init__ ( self , manufacturer, model, hp):\rself .manufacturer = manufacturer\rself .model = model\rself .hp = hp\rCar.amount_cars += 1\rdef print_car_amount( self ):\rprint ( \u0026#39;Amount: {}\u0026#39;.format(Car.amount_cars)) def print_info( self ):\rprint ( \u0026#39;Manufacturer: {}, Model: {}, HP; {}\u0026#39;.format( self .manufacturer, self.model,self.hp)) \rThe variable amount_cars doesn’t belong to the individual object since it’s not addressed with self . It is a class variable and its value is the same for all objects or instances.\rWhenever we create a new car object, it increases by one. Then, every object can access and print the amount of existing cars.\n\rDESTRUCTORS\rIn Python, we can also specify a method that gets called when our object gets destroyed or deleted and is no longer needed. This function is called destructor and it is the opposite of the constructor .\nclass Car:\ramount_cars = 0\rdef __init__ ( self , manufacturer, model, hp):\rself.manufacturer = manufacturer\rself.model = model\rself.hp = hp\rCar.amount_cars += 1\rdef __del__ ( self ):\rprint ( \u0026#39;Object gets deleted!\u0026#39; )\rCar.amount_cars -= 1 def print_car_amount( self ):\rprint ( \u0026#39;Amount: {}\u0026#39;.format(Car.amount_cars)) def print_info( self ):\rprint ( \u0026#39;Manufacturer: {}, Model: {}, HP; {}\u0026#39;.format( self .manufacturer, self.model,self.hp)) \rThe destructor function is called del . In this example, we print an informational message and decrease the amount of existing cars by one, when an object gets deleted.\n\rCREATING OBJECTS\rNow that we have implemented our class, we can start to create some objects of it.\nmyCar1 = Car( \u0026#39;Tesla1\u0026#39; , \u0026#39;Model X1\u0026#39; , 5251 )\rFirst, we specify the name of our object, like we do with ordinary variables. In this case, the object is called myCar1 . We then create an object of the Car class by writing the class name as a function. This calls the constructor, so we can pass our parameters. We can then use the functions of our car object.\nmyCar1.print_info()\r## Manufacturer: Tesla1, Model: Model X1, HP; 5251\rmyCar1.print_car_amount()\r## Amount: 1\rThe results look like this:\rManufacturer: Tesla, Model: Model X, HP; 525\rAmount: 1\rWhat you can also do is directly access the attributes of an object.\nprint (myCar1.manufacturer)\r## Tesla1\rprint (myCar1.model)\r## Model X1\rprint (myCar1.hp)\r## 5251\rNow we can create some more cars and see how the amount changes.\nmyCar1 = Car( \u0026#39;Tesla1\u0026#39; , \u0026#39;Model X1\u0026#39; , 525 )\r## Object gets deleted!\rmyCar2 = Car( \u0026#39;BMW1\u0026#39; , \u0026#39;X31\u0026#39; , 2001 )\rmyCar3 = Car( \u0026#39;VW1\u0026#39; , \u0026#39;Golf1\u0026#39; , 1001)\rmyCar4 = Car( \u0026#39;Porsche1\u0026#39; , \u0026#39;9111\u0026#39; , 5201 )\rdel myCar3\r## Object gets deleted!\rmyCar1.print_car_amount()\r## Amount: 3\rHere we first create four different car objects. We then delete one of them and finally we print out the car amount. The result is the following:\rObject gets deleted!\rAmount: 3\rNotice that all the objects get deleted automatically when our program ends. But we can manually delete them before that happens by using the del keyword.\n\rHIDDEN ATTRIBUTES\rIf we want to create hidden attributes that can only be accessed within the class, we can do this with underlines .\nclass MyClass:\rdef __init__ ( self ):\rself.__hidden = \u0026#39;Hello\u0026#39;\rprint ( self .__hidden) # Works\rm1 = MyClass()\r# print (m1.__hidden) # Doesn\u0026#39;t Work \r## Hello\rBy putting two underlines before the attribute name, we make it invisible from outside the class. The first print function works because it is inside of the class. But when we try to access this attribute from the object, we can’t.\n\rINHERITANCE\rOne very important and powerful concept of object-oriented programming is inheritance . It allows us to use existing classes and to extend them with new attributes and functions.\rFor example, we could have the parent class which represents a Person and then we could have many child classes like Dancer, Policeman, Artist etc. All of these would be considered a person and they would have the same basic attributes. But they are special kinds of persons with more attributes and functions.\nclass Person:\rdef __init__ ( self , name, age):\rself .name = name\rself .age = age\rdef get_older( self , years):\rself .age += years\rclass Programmer(Person):\rdef __init__ ( self , name, age, language):\rsuper (Programmer, self ). __init__ (name, age)\rself .language = language\rdef print_language( self ):\rprint ( \u0026#39;Favorite Programming Language: {}\u0026#39;.format( self .language)) \r\r",
    "ref": "/blog/python-basics-2/"
  },{
    "title": "Python - 1",
    "date": "",
    "description": "Introduction to Python.",
    "body": "\r\rVARIABLES AND DATA TYPES\rVariables and Data types basically are just placeholders for values. In programming, that’s the same. The difference is that we have a lot of different data types, and variables cannot only store values of numbers but even of whole objects.\rIn this chapter we are going to take a look at variables in Python and the differences of the individual data types. Also, we will talk about type conversions.\nNUMERICAL DATA TYPES\rThe types you probably already know from mathematics are numerical data types. There are different kinds of numbers that can be used for mathematical operations.\n\r\rNUMERICAL DATA TYPES\r\r\r\r\r\rInteger\rint\rwhole number\r\rFloat\rfloat\rfloating point number\r\rComplex\rcomplex\rcomplex number\r\r\r\rAs you can see, it’s quite simple. An integer is just a regular whole number, which we can do basic calculations with. A float extends the integer and allows decimal places because it is a floating point number. And a complex number is what just a number that has a real and an imaginary component. If you don’t understand complex numbers mathematically, forget about them. You don’t need them for your programming right now.\n\rSTRINGS\rA string defines characters sequences. Our text that we printed in the last chapter was a string. Strings always need to be surrounded by quotation marks. Otherwise the interpreter will not realize that they are meant to be treated like text. The keyword for String in Python is str .\n\rBOOLEANS\rBoolean are the most simple data type in Python. They can only have one of two values, namely True or False . It’s a binary data type. We will use it a lot when we get to conditions and loops. The keyword here is bool .\n\rSEQUENCES\rSequences are a topic that we will cover in a later chapter. But since sequences are also data types we will at least mention that they exist.\n\r\rSEQUENCE TYPES\r\r\r\r\r\rList\rlist\rColection of values\r\rTuple\rtuple\rImutable list\r\rDictionary\rdict\rList of key nd value pairs\r\r\r\r\rCREATING VARIABLES\rCreating variables in Python is very simple. We just choose a name and assign a value.\nmyNumber = 10\rmyText = \u0026#39;Hello\u0026#39; \rHere, we defined two variables. The first one is an integer and the second one a string. You can basically choose whatever name you want but there are some limitations. For example you are not allowed to use reserved keywords like int or dict . Also, the name is not allowed to start with a number or a special character other than the underline.\n\rUSING VARIABLES\rNow that we have defined our variables, we can start to use them. For example, we could print the values.\nprint (myNumber)\r## 10\rprint (myText)\r## Hello\rSince we are not using quotation marks, the text in the parentheses is treated like a variable name. Therefore, the interpreter prints out the values 10 and “Hello” .\n\rTYPECASTING\rSometimes, we will get a value in a data type that we can’t work with properly. For example we might get a string as an input but that string contains a number as its value. Here “10” is not same to 10 . We can’t do calculations with a string, even if the text represents a number. For that reason we need to typecast.\nvalue = \u0026#39;10\u0026#39;\rnumber = int (value)\rTypecasting is done by using the specific data type function. In this case we are converting a string to an integer by using the int keyword. You can also reverse this by using the str keyword. This is a very important thing and we will need it quite often.\n\r\rPython loops and types\r\r1. For loop\rnumbers = [10,20,30,40]\rfor num in numbers:\rprint(num)\r\r## 10\r## 20\r## 30\r## 40\rfor num in range(10,41,10):\rprint(num)\r## 10\r## 20\r## 30\r## 40\r\r2. While loop\rnumber = 0\rwhile number \u0026lt; 10:\rnumber += 1\rif number == 5:\rbreak\rprint(number)\r## 1\r## 2\r## 3\r## 4\rnum = 0\rwhile num \u0026lt; 10:\rnum += 1\rif num == 5:\rcontinue\rprint(num)\r## 1\r## 2\r## 3\r## 4\r## 6\r## 7\r## 8\r## 9\r## 10\r\r3. Sequences - Lists\rnumbers = [10, 20, 30 ,40]\rnames = [\u0026#39;Arun\u0026#39;,\u0026#39;Varun\u0026#39;,\u0026#39;Karun\u0026#39;]\rmixed = [10,\u0026#39;Arun\u0026#39;, 28.3,True ]\rprint(numbers[3])\r## 40\rprint(names[0])\r## Arun\rprint(mixed[3])\r## True\rnumbers[3] = 3\rnames[2] = \u0026#39;Bob\u0026#39;\rprint(numbers[3])\r## 3\rprint(names[2])\r## Bob\r\r4. Sequences - Lists - Operations\r\r\rLIST OPERATIONS\r\r\r\r\rOPERATION\rRESULT\r\r[10, 20, 30] + [40, 50, 60]\r[10, 20, 30, 40, 50, 60]\r\r[10, “Bob”] * 3\r[10, “Bob”, 10, “Bob”, 10, “Bob”]\r\r\r\r\r5. Sequences - Lists - Functions\r\r\rLIST FUNCTIONS\r\r\r\r\rFUNCTION\rDESCRIPTION\r\rlen(list)\rReturns the length of a list\r\rmax(list)\rReturns the item with maximum value\r\rmin(list)\rReturns the item with minimum value\r\rlist(element)\rTypecasts element into list\r\r\r\r\r6. Sequences - Lists - METHODS\r\r\rLIST METHODS\r\r\r\r\rMETHOD\rDESCRIPTION\r\rlist.append(x)\rAppends element to the list\r\rlist.count(x)\rCounts how many times an element appears in the list\r\rlist.index(x)\rReturns the first index at which the given element occurs\r\rlist.pop()\rRemoves and returns last element\r\rlist.reverse()\rReverses the order of the elements\r\rlist.sort()\rSorts the elements of a list\r\r\r\r\r7. Sequences - Tupples\rtpl = (10,20,30)\rlen(tpl)\r## 3\rmax(tpl)\r## 30\rmin(tpl)\r## 10\r\r",
    "ref": "/blog/python-basics/"
  },{
    "title": "Kontakt",
    "date": "",
    "description": "",
    "body": "",
    "ref": "/contact/"
  }]
