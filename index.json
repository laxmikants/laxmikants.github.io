[{
    "title": "React- JS",
    "date": "",
    "description": "React JS Programming",
    "body": "\r\r*** React-JS\nView Slides\n\r",
    "ref": "/blog/react-js/"
  },{
    "title": "Pandas (Python)",
    "date": "",
    "description": "Pandas is a software module for the Python programming language for the purpose of data manipulation and analysis. It provides data structures and operations to  manipulate numerical tables and time series data. It is build on top of numpy. It is applied for fast analysis and data cleaning and preparation.In this post we will learn various wasy to work with Pandas DataFrames.",
    "body": "\r\r\rPandas\r\rPandas Series\rPANDAS DataFrame\r\r\r\rPandas\rPandas is probably the most powerful library. It provides high-performance tools for data manipulation and analysis. Furthermore, it is very effective at converting data formats and querying data out of databases. The two main data structures of Pandas are the series and the data frame. To work with Pandas, we need to import the module.\nimport pandas as pd\rPandas Series\rA series in Pandas is a one-dimensional array which is labeled. You can imagine it to be the equivalent of an ordinary Python dictionary.\nseries = pd.Series([ 10 , 20 , 30 , 40 ],\r[ \u0026#39;A\u0026#39; , \u0026#39;B\u0026#39; , \u0026#39;C\u0026#39; , \u0026#39;D\u0026#39; ])\rIn order to create a series, we use the constructor of the Series class. The first parameter that we pass is a list full of values (in this case numbers). The second parameter is the list of the indices or keys (in this case strings). When we now print our series, we can see what the structure looks like.\nprint(series)\r## A 10\r## B 20\r## C 30\r## D 40\r## dtype: int64\rThe first column represents the indices, whereas the second column represents the actual values.\nACCESSING VALUES\rThe accessing of values works in the same way that it works with dictionaries. We need to address the respective index or key to get our desired value.\nprint (series[ \u0026#39;C\u0026#39; ])\r## 30\rprint (series[ 1 ])\r## 20\rAs you can see, we can choose how we want to access our elements. We can either address the key or the position that the respective element is at.\nCONVERTING DICTIONARIES\nSince series and dictionaries are quite similar, we can easily convert our Python dictionaries into Pandas series.\nmyDict = { \u0026#39;A\u0026#39; : 10 , \u0026#39;B\u0026#39; : 20 , \u0026#39;C\u0026#39; : 30 }\rseries = pd.Series(myDict)\rNow the keys are our indices and the values remain values. But what we can also do is, to change the order of the indices.\nmyDict = { \u0026#39;A\u0026#39; : 10 , \u0026#39;B\u0026#39; : 20 , \u0026#39;C\u0026#39; : 30 }\rseries = pd.Series(myDict, index =[ \u0026#39;C\u0026#39; , \u0026#39;A\u0026#39; , \u0026#39;B\u0026#39; ])\rOur series now looks like this:\nprint(series)\r## C 30\r## A 10\r## B 20\r## dtype: int64\r\r\rPANDAS DataFrame\rDataFrame is the main thing on which we’ll be mostly working on. Most manipulation or operation on the data will be applied by means of DataFrame.\nCreating DataFrame using dictionary data\rThis is a simple process in which we just need to pass the json data to the DataFrame method.\ncars = {\u0026#39;Brand\u0026#39;:[\u0026#39;Honda\u0026#39;,\u0026#39;Toyota\u0026#39;,\u0026#39;Ford\u0026#39;,\u0026#39;Audi\u0026#39;],\u0026#39;Price\u0026#39;:[22000,21000,27000,35000]}\rdf = pd.DataFrame(cars)\rdf\r## Brand Price\r## 0 Honda 22000\r## 1 Toyota 21000\r## 2 Ford 27000\r## 3 Audi 35000\rdata = { \u0026#39;Name\u0026#39; : [ \u0026#39;Anna\u0026#39; , \u0026#39;Bob\u0026#39; , \u0026#39;Charles\u0026#39; ], \u0026#39;Age\u0026#39; : [ 24 , 32 , 35 ], \u0026#39;Height\u0026#39; : [ 176 , 187 , 175 ]}\rdf = pd.DataFrame(data)\rTo create a Pandas data frame, we use the constructor of the class. In this case, we first create a dictionary with some data about three persons. We feed that data into our data frame. It then looks like this:\ndf\r## Name Age Height\r## 0 Anna 24 176\r## 1 Bob 32 187\r## 2 Charles 35 175\rAs you can see, without any manual work, we already have a structured data frame and table.\nTo now access the values is a bit more complicated than with series. We have multiple columns and multiple rows, so we need to address two values.\nprint (df[ \u0026#39;Name\u0026#39; ][ 1 ])\r## Bob\rSo first we choose the column Name and then we choose the second element (index one) of this column. In this case, this is Bob .\nWhen we omit the last index, we can also select only the one column. This is useful when we want to save specific columns of our data frame into a new one. What we can also do in this case is to select multiple columns.\nprint (df[[ \u0026#39;Name\u0026#39; , \u0026#39;Height\u0026#39; ]])\r## Name Height\r## 0 Anna 176\r## 1 Bob 187\r## 2 Charles 175\r\rDATA FRAME FUNCTIONS\rFor data frames we have a couple of basic functions and attributes that we already know from lists or NumPy arrays.\n\r\rBASIC FUNCTIONS AND ATTRIBUTES\r\r\r\r\rdf.T\rTransposes the rows and columns of the data frame\r\rdf.dtypes\rReturns data types of the data frame\r\rdf.ndim\rReturns the number of dimensions of the data frame\r\rdf.shape\rReturns the shape of the data frame\r\rdf.size\rReturns the number of elements in the data frame\r\rdf.head(n)\rReturns the first n rows of the data frame (default is five)\r\rdf.tail(n)\rReturns the last n rows of the data frame (default is five)\r\r\r\r\rSTATISTICAL FUNCTIONS\rFor the statistical functions, we will now extend our data frame a little bit and add some more persons.\ndata = { \u0026#39;Name\u0026#39; : [ \u0026#39;Anna\u0026#39; , \u0026#39;Bob\u0026#39; , \u0026#39;Charles\u0026#39; ,\r\u0026#39;Daniel\u0026#39; , \u0026#39;Evan\u0026#39; , \u0026#39;Fiona\u0026#39; ,\r\u0026#39;Gerald\u0026#39; , \u0026#39;Henry\u0026#39; , \u0026#39;India\u0026#39; ],\r\u0026#39;Age\u0026#39; : [ 24 , 32 , 35 , 45 , 22 , 54 , 55 , 43 , 25 ],\r\u0026#39;Height\u0026#39; : [ 176 , 187 , 175 , 182 , 176 ,\r189 , 165 , 187 , 167 ]}\rdf = pd.DataFrame(data)\r\r\rSTATISTICAL FUNCTIONS\r\r\r\r\rFUNCTION\rDESCRIPTION\r\rcount()\rCount the number of non-null elements\r\rsum()\rReturns the sum of values of the selected columns\r\rmean()\rReturns the arithmetic mean of values of the selected columns\r\rmedian()\rReturns the median of values of the selected columns\r\rmode()\rReturns the value that occurs most often in the columns selected\r\rstd()\rReturns standard deviation of the values\r\rmin()\rReturns the minimum value\r\rmax()\rReturns the maximum value\r\rabs()\rReturns the absolute values of the elements\r\rprod()\rReturns the product of the selected elements\r\rdescribe()\rReturns data frame with all statistical values summarized\r\r\r\rNow, we are not going to dig deep into every single function here. But let’s take a look at how to apply some of them.\nprint (df[ \u0026#39;Age\u0026#39; ].mean())\r## 37.22222222222222\rprint (df[ \u0026#39;Height\u0026#39; ].median())\r## 176.0\rHere we choose a column and then apply the statistical functions on it. What we get is just a single scalar with the desired value.\nWe can also apply the functions to the whole data frame. In this case, we get returned another data frame with the results for each column.\nprint (df.mean())\r## Age 37.222222\r## Height 178.222222\r## dtype: float64\r\rAPPLYING NUMPY FUNCTIONS\rInstead of using the built-in Pandas functions, we can also use the methods we already know. For this, we just use the apply function of the data frame and then pass our desired method.\nimport numpy as np\rprint (df[ \u0026#39;Age\u0026#39; ].apply(np.sin))\r## 0 -0.905578\r## 1 0.551427\r## 2 -0.428183\r## 3 0.850904\r## 4 -0.008851\r## 5 -0.558789\r## 6 -0.999755\r## 7 -0.831775\r## 8 -0.132352\r## Name: Age, dtype: float64\rIn this example, we apply the sine function onto our ages. It doesn’t make any sense but it demonstrates how this works.\n\rLAMBDA EXPRESSIONS\rA very powerful in Python are lambda expression . They can be thought of as nameless functions that we pass as a parameter.\nprint (df[ \u0026#39;Age\u0026#39; ].apply( lambda x: x * 100 ))\r## 0 2400\r## 1 3200\r## 2 3500\r## 3 4500\r## 4 2200\r## 5 5400\r## 6 5500\r## 7 4300\r## 8 2500\r## Name: Age, dtype: int64\rBy using the keyword lambda we create a temporary variable that represents the individual values that we are applying the operation onto. After the colon, we define what we want to do. In this case, we multiply all values of the column Age by 100.\ndf = df[[ \u0026#39;Age\u0026#39; , \u0026#39;Height\u0026#39; ]]\rprint (df.apply( lambda x: x.max() - x.min()))\r## Age 33\r## Height 24\r## dtype: int64\rHere we removed the Name column, so that we only have numerical values. Since we are applying our expression on the whole data frame now, x refers to the whole columns. What we do here is calculating the difference between the maximum value and the minimum value.\n\rITERATING\rIterating over data frames is quite easy with Pandas. We can either do it in the classic way or use specific functions for it.\nfor x in df[ \u0026#39;Age\u0026#39; ]:\rprint (x)\r## 24\r## 32\r## 35\r## 45\r## 22\r## 54\r## 55\r## 43\r## 25\rAs you can see, iterating over a column’s value is very simple and nothing new. This would print all the ages. When we iterate over the whole data frame, our control variable takes on the column names.\n\r\rSTATISTICAL FUNCTIONS\r\r\r\r\riteritems()\rIterator for key-value pairs\r\riterrows()\rIterator for the rows (index, series)\r\ritertuples()\rIterator for the rows as named tuples\r\r\r\rLet’s take a look at some practical examples.\nfor key, value in df.iteritems():\rprint ( \u0026#39;{}: {}\u0026#39; .format(key, value))\r## Age: 0 24\r## 1 32\r## 2 35\r## 3 45\r## 4 22\r## 5 54\r## 6 55\r## 7 43\r## 8 25\r## Name: Age, dtype: int64\r## Height: 0 176\r## 1 187\r## 2 175\r## 3 182\r## 4 176\r## 5 189\r## 6 165\r## 7 187\r## 8 167\r## Name: Height, dtype: int64\rHere we use the iteritems function to iterate over key-value pairs. What we get is a huge output of all rows for each column.\nOn the other hand, when we use iterrows , we can print out all the column-values for each row or index.\nfor index, value in df.iterrows():\rprint (index,value)\r## 0 Age 24\r## Height 176\r## Name: 0, dtype: int64\r## 1 Age 32\r## Height 187\r## Name: 1, dtype: int64\r## 2 Age 35\r## Height 175\r## Name: 2, dtype: int64\r## 3 Age 45\r## Height 182\r## Name: 3, dtype: int64\r## 4 Age 22\r## Height 176\r## Name: 4, dtype: int64\r## 5 Age 54\r## Height 189\r## Name: 5, dtype: int64\r## 6 Age 55\r## Height 165\r## Name: 6, dtype: int64\r## 7 Age 43\r## Height 187\r## Name: 7, dtype: int64\r## 8 Age 25\r## Height 167\r## Name: 8, dtype: int64\r\rSORTING\rOne very powerful thing about Pandas data frames is that we can easily sort them.\n\rSORT BY INDEX\rdf = pd.DataFrame(np.random.rand( 10 , 2 ),\rindex =[ 1 , 5 , 3 , 6 , 7 , 2 , 8 , 9 , 0 , 4 ],\rcolumns =[ \u0026#39;A\u0026#39; , \u0026#39;B\u0026#39; ])\rHere we create a new data frame, which is filled with random numbers. We specify our own indices and as you can see, they are completely unordered.\nprint (df.sort_index())\r## A B\r## 0 0.562505 0.040337\r## 1 0.883686 0.588891\r## 2 0.208641 0.995449\r## 3 0.777559 0.013390\r## 4 0.440708 0.871428\r## 5 0.834310 0.362585\r## 6 0.613967 0.194045\r## 7 0.410843 0.701929\r## 8 0.332524 0.407086\r## 9 0.427685 0.712622\rBy using the method sort_index , we sort the whole data frame by the index column. The result is now sorted:\n\rINPLACE PARAMETER\rWhen we use functions that manipulate our data frame, we don’t actually change it but we return a manipulated copy. If we wanted to apply the changes on the actual data frame, we would need to do it like this:\ndf = df.sort_index()\rBut Pandas offers us another alternative as well. This alternative is the parameter inplace . When this parameter is set to True , the changes get applied to our actual data frame\ndf.sort_index( inplace = True )\r\rSORT BY COLUMNS\rNow, we can also sort our data frame by specific columns.\ndata = { \u0026#39;Name\u0026#39; : [ \u0026#39;Anna\u0026#39; , \u0026#39;Bob\u0026#39; , \u0026#39;Charles\u0026#39; ,\r\u0026#39;Daniel\u0026#39; , \u0026#39;Evan\u0026#39; , \u0026#39;Fiona\u0026#39; ,\r\u0026#39;Gerald\u0026#39; , \u0026#39;Henry\u0026#39; , \u0026#39;India\u0026#39; ],\r\u0026#39;Age\u0026#39; : [ 24 , 24 , 35 , 45 , 22 , 54 , 54 , 43 , 25 ],\r\u0026#39;Height\u0026#39; : [ 176 , 187 , 175 , 182 , 176 ,\r189 , 165 , 187 , 167 ]}\rdf = pd.DataFrame(data)\rdf.sort_values( by =[ \u0026#39;Age\u0026#39; , \u0026#39;Height\u0026#39; ], inplace = True )\rprint (df)\r## Name Age Height\r## 4 Evan 22 176\r## 0 Anna 24 176\r## 1 Bob 24 187\r## 8 India 25 167\r## 2 Charles 35 175\r## 7 Henry 43 187\r## 3 Daniel 45 182\r## 6 Gerald 54 165\r## 5 Fiona 54 189\rHere we have our old data frame slightly modified. We use the function sort_values to sort our data frames. The parameter by states the columns that we are sorting by. In this case, we are first sorting by age and if two persons have the same age, we sort by height.\n\rJOINING AND MERGING\rAnother powerful concept in Pandas is joining and merging data frames.\nnames = pd.DataFrame({\r\u0026#39;id\u0026#39; : [ 1 , 2 , 3 , 4 , 5 ],\r\u0026#39;name\u0026#39; : [ \u0026#39;Anna\u0026#39; , \u0026#39;Bob\u0026#39; , \u0026#39;Charles\u0026#39; ,\r\u0026#39;Daniel\u0026#39; , \u0026#39;Evan\u0026#39; ],\r})\rages = pd.DataFrame({\r\u0026#39;id\u0026#39; : [ 1 , 2 , 3 , 4 , 5 ],\r\u0026#39;age\u0026#39; : [ 20 , 30 , 40 , 50 , 60 ]\r})\rdf = pd.merge(names,ages, on = \u0026#39;id\u0026#39; )\rdf.set_index( \u0026#39;id\u0026#39; , inplace = True )\rFirst we use the method merge and specify the column to merge on. We then have a new data frame with the combined data but we also want our id column to be the index. For this, we use the set_index method.\rNow when we have two separate data frames which are related to one another, we can combine them into one data frame. It is important that we have a common column that we can merge on. In this case, this is id .\n\rJOINS\rIt is not necessarily always obvious how we want to merge our data frames. This is where joins come into play. We have four types of joins.\n\r\rJOIN MERGE TYPES\r\r\r\r\rleft\rUses all keys from left object and merges with right\r\rright\rUses all keys from right object and merges with left\r\router\rUses all keys from both objects and merges them\r\rinner\rUses only the keys which both objects have and merges them\r\r\r(default)\r\r\r\rNow let’s change our two data frames a little bit.\nnames = pd.DataFrame({\r\u0026#39;id\u0026#39; : [ 1 , 2 , 3 , 4 , 5 , 6 ],\r\u0026#39;name\u0026#39; : [ \u0026#39;Anna\u0026#39; , \u0026#39;Bob\u0026#39; , \u0026#39;Charles\u0026#39; ,\r\u0026#39;Daniel\u0026#39; , \u0026#39;Evan\u0026#39; , \u0026#39;Fiona\u0026#39; ],\r})\rages = pd.DataFrame({\r\u0026#39;id\u0026#39; : [ 1 , 2 , 3 , 4 , 5 , 7 ],\r\u0026#39;age\u0026#39; : [ 20 , 30 , 40 , 50 , 60 , 70 ],\r\u0026#39;Height\u0026#39; : [ 176 , 187 , 175 , 182 , 176 ,\r189 ]\r})\rOur names frame now has an additional index 6 and an additional name. And our ages frame has an additional index 7 with an additional name.\ndf = pd.merge(names,ages, on = \u0026#39;id\u0026#39; , how = \u0026#39;inner\u0026#39; )\rdf.set_index( \u0026#39;id\u0026#39; , inplace = True )\rIf we now perform the default inner join , we will end up with the same data frame as in the beginning. We only take the keys which both objects have. This means one to five.\ndf = pd.merge(names,ages, on = \u0026#39;id\u0026#39; , how = \u0026#39;left\u0026#39; )\rdf.set_index( \u0026#39;id\u0026#39; , inplace = True )\rWhen we use the left join , we get all the keys from the names data frame but not the additional index 7 from ages. This also means that Fiona won’t be assigned any age.\nThe same principle goes for the right join just the other way around\ndf = pd.merge(names,ages, on = \u0026#39;id\u0026#39; , how = \u0026#39;right\u0026#39; )\rdf.set_index( \u0026#39;id\u0026#39; , inplace = True )\rNow, we only have the keys from the ages frame and the 6 is missing. Finally, if we use the outer join , we combine all keys into one data frame.\ndf = pd.merge(names,ages, on = \u0026#39;id\u0026#39; , how = \u0026#39;outer\u0026#39; )\rdf.set_index( \u0026#39;id\u0026#39; , inplace = True )\r\rQUERYING DATA\rLike in databases with SQL, we can also query data from our data frames in Pandas. For this, we use the function loc , in which we put our expression.\nprint (df.loc[df[ \u0026#39;age\u0026#39; ] == 24 ])\r## Empty DataFrame\r## Columns: [name, age, Height]\r## Index: []\rprint (df.loc[(df[ \u0026#39;age\u0026#39; ] == 24 ) \u0026amp;\r(df[ \u0026#39;Height\u0026#39; ] \u0026gt; 180 )])\r## Empty DataFrame\r## Columns: [name, age, Height]\r## Index: []\rprint (df.loc[df[ \u0026#39;age\u0026#39; ] \u0026gt; 30 ][ \u0026#39;name\u0026#39; ])\r## id\r## 3 Charles\r## 4 Daniel\r## 5 Evan\r## 7 NaN\r## Name: name, dtype: object\rHere we have some good examples to explain how this works. The first expression returns all rows where the value for Age is 24.\nThe second query is a bit more complicated. Here we combine two conditions. The first one is that the age needs to be 24 but we then combine this with the condition that the height is greater than 180. This leaves us with one row.\nIn the last expression, we can see that we are only choosing one column to be returned. We want the names of all people that are older than 30.\n\rREAD DATA FROM FILES\rSimilar to NumPy, we can also easily read data from external files into Pandas. Let’s say we have an CSV-File like this (opened in Excel):\nThe only thing that we need to do now is to use the function read_csv to import our data into a data frame.\ndf = pd.read_csv( \u0026#39;data.csv\u0026#39; )\rdf.set_index( \u0026#39;id\u0026#39; , inplace = True )\rprint (df)\rWe also set the index to the id column again. This is what we have imported:\nThis of course, also works the other way around. By using the method to_csv , we can also save our data frame into a CSV-file.\ndata = { \u0026#39;Name\u0026#39; : [ \u0026#39;Anna\u0026#39; , \u0026#39;Bob\u0026#39; , \u0026#39;Charles\u0026#39; ,\r\u0026#39;Daniel\u0026#39; , \u0026#39;Evan\u0026#39; , \u0026#39;Fiona\u0026#39; ,\r\u0026#39;Gerald\u0026#39; , \u0026#39;Henry\u0026#39; , \u0026#39;India\u0026#39; ],\r\u0026#39;Age\u0026#39; : [ 24 , 24 , 35 , 45 , 22 , 54 , 54 , 43 , 25 ],\r\u0026#39;Height\u0026#39; : [ 176 , 187 , 175 , 182 , 176 ,\r189 , 165 , 187 , 167 ]}\rdf = pd.DataFrame(data)\rdf.to_csv( \u0026#39;mydf.csv\u0026#39; )\r\rPLOTTING DATA\rSince Pandas builds on Matplotlib, we can easily visualize the data from our data frame.\ndata = { \u0026#39;Name\u0026#39; : [ \u0026#39;Anna\u0026#39; , \u0026#39;Bob\u0026#39; , \u0026#39;Charles\u0026#39; ,\r\u0026#39;Daniel\u0026#39; , \u0026#39;Evan\u0026#39; , \u0026#39;Fiona\u0026#39; ,\r\u0026#39;Gerald\u0026#39; , \u0026#39;Henry\u0026#39; , \u0026#39;India\u0026#39; ],\r\u0026#39;Age\u0026#39; : [ 24 , 24 , 35 , 45 , 22 , 54 , 54 , 43 , 25 ],\r\u0026#39;Height\u0026#39; : [ 176 , 187 , 175 , 182 , 176 ,\r189 , 165 , 187 , 167 ]}\rdf = pd.DataFrame(data)\rdf.sort_values( by =[ \u0026#39;Age\u0026#39; , \u0026#39;Height\u0026#39; ])\rdf.hist()\rplt.show()\rIn this example, we use the method hist to plot a histogram of our numerical columns. Without specifying anything more, this is what we end up with:\nBut we can also just use the function plot to plot our data frame or individual columns.\ndf.plot()\rplt.show()\rThe result is the following:\n\r\r\r",
    "ref": "/blog/pandas/"
  },{
    "title": "Python - Matplotlib- Plot Types",
    "date": "",
    "description": "Matplotlib- Plot Types",
    "body": "\r\r\rMATPLOTLIB PLOT TYPES\r\r\rMATPLOTLIB PLOT TYPES\rIn the last chapter, we mainly plotted functions and a couple of values. But Matplotlib offers a huge arsenal of different plot types. Here we are going to take a look at these.\nHISTOGRAMS\rLet’s start out with some statistics here. So-called histograms represent the distribution of numerical values. For example, we could graph the distribution of heights amongst students in a class.\nmu, sigma = 172 , 4\rx = mu + sigma * np.random.randn( 10000 ) \rWe start by defining a mean value mu (average height) and a standard deviation sigma . To create our x-values, we use our mu and sigma combined with 10000 randomly generated values. Notice that we are using the randn function here. This function generates values for a standard normal distribution , which means that we will get a bell curve of values.\nplt.hist(x, 100 , density = True , facecolor = \u0026#39;blue\u0026#39; ) \rThen we use the hist function, in order to plot our histogram. The second parameter states how many values we want to plot. Also, we want our values to be normed. So we set the parameter density to True . This means that our y-values will sum up to one and we can view them as percentages. Last but not least, we set the color to blue.\nNow, when we show this plot, we will realize that it is a bit confusing. So we are going to add some labeling here.\nplt.xlabel( \u0026#39;Height\u0026#39; )\rplt.ylabel( \u0026#39;Probability\u0026#39; )\rplt.title( \u0026#39;Height of Students\u0026#39; )\rplt.text( 160 , 0.125 , \u0026#39;µ = 172, σ = 4\u0026#39; )\rplt.axis([ 155 , 190 , 0 , 0.15 ])\rplt.grid( True )\rFirst we label the two axes. The x-values represent the height of the students, whereas the y-values represent the probability that a randomly picked student has the respective height. Besides the title, we also add some text to our graph. We place it at the x-value 160 and the y-value of 0.125. The text just states the values for µ (mu) and σ (sigma).\nLast but not least, we set the ranges for the two axes. Our x-values range from 155 to 190 and our y-values from 0 to 0.15. Also, the grid is turned on. This is what our graph looks like at the end:\nWe can see the Gaussian bell curve which is typical for the standard normal distribution.\n\rBAR CHART\rFor visualizing certain statistics, bar charts are oftentimes very useful, especially when it comes to categories. In our case, we are going to plot the skill levels of three different people in the IT realm.\nbob = ( 90 , 67 , 87 , 76 )\rcharles = ( 80 , 80 , 47 , 66 )\rdaniel = ( 40 , 95 , 76 , 89 )\rskills = ( \u0026#39;Python\u0026#39; , \u0026#39;Java\u0026#39; , \u0026#39;Networking\u0026#39; , \u0026#39;Machine Learning\u0026#39; )\rHere we have the three persons Bob, Charles and Daniel . They are represented by tuples with four values that indicate their skill levels in Python programming, Java programming, networking and machine learning.\nwidth = 0.2\rindex = np.arange( 4 )\rplt.bar(index, bob,\rwidth =width, label = \u0026#39;Bob\u0026#39; )\rplt.bar(index + width, charles,\rwidth =width, label = \u0026#39;Charles\u0026#39; )\rplt.bar(index + width * 2 , daniel,width =width, label = \u0026#39;Daniel\u0026#39; )\rWe then use the bar function to plot our bar chart. For this, we define an array with the indices one to four and a bar width of 0.2. For each person we plot the four respective values and label them.\nplt.xticks(index + width, skills)\rplt.ylim( 0 , 120 )\rplt.title( \u0026#39;IT Skill Levels\u0026#39; )\rplt.ylabel( \u0026#39;Skill Level\u0026#39; )\rplt.xlabel( \u0026#39;IT Skill\u0026#39; )\rplt.legend()\rThen we label the x-ticks with the method xticks and set the limit of the y-axis to 120 to free up some space for our legend. After that we set a title and label the axes. The result looks like this:\nWe can now see who is the most skilled in each category. Of course we could also change the graph so that we have the persons on the x-axis with the skill-colors in the legend.\n\rPIE CHART\rPie charts are used to display proportions of numbers. For example, we could graph how many percent of the students have which nationality.\nlabels = ( \u0026#39;American\u0026#39; , \u0026#39;German\u0026#39; , \u0026#39;French\u0026#39; , \u0026#39;Other\u0026#39; )\rvalues = ( 47 , 23 , 20 , 10 ) \rWe have one tuple with our four nationalities. They will be our labels. And we also have one tuple with the percentages.\nplt.pie(values, labels =labels,\rautopct = \u0026#39;%.2f%%\u0026#39; , shadow = True )\rplt.title( \u0026#39;Student Nationalities\u0026#39; )\rplt.show()\rNow we just need to use the pie function, to draw our chart. We pass our values and our labels. Then we set the autopct parameter to our desired percentage format. Also, we turn on the shadow of the chart and set a title. And this is what we end up with:\nAs you can see, this chart is perfect for visualizing percentages.\n\rSCATTER PLOTS\rSo-called scatter plots are used to represent two-dimensional data using dots.\nx = np.random.rand( 50 )\ry = np.random.rand( 50 )\rplt.scatter(x,y)\rplt.show()\rHere we just generate 50 random x-values and 50 random y-values. By using the scatter function, we can then plot them.\n\rBOXPLOT\rBoxplot diagrams are used, in order to split data into quartiles . We do that to get information about the distribution of our values. The question we want to answer is: How widely spread is the data in each of the quartiles.\nmu, sigma = 172 , 4\rvalues = np.random.normal(mu,sigma, 200 )\rplt.boxplot(values)\rplt.title( \u0026#39;Student\u0026#39;s Height\u0026#39; )\rplt.ylabel( \u0026#39;Height\u0026#39; )\rplt.show()\rIn this example, we again create a normal distribution of the heights of our students. Our mean value is 172, our standard deviation 4 and we generate 200 values. Then we plot our boxplot diagram.\nHere we see the result. Notice that a boxplot doesn’t give information about the frequency of the individual values. It only gives information about the spread of the values in the individual quartiles. Every quartile has 25% of the values but some have a very small spread whereas others have quite a large one.\n\r3D PLOTS\rNow last but not least, let’s take a look at 3D-plotting. For this, we will need to import another plotting module. It is called mpl_toolkits and it is part of the Matplotlib stack.\nfrom mpl_toolkits import mplot3d\rSpecifically, we import the module mplot3d from this library. Then, we can use 3d as a parameter when defining our axes.\nax = plt.axes( projection = \u0026#39;3d\u0026#39; )\rplt.show()\rWe can only use this parameter, when mplot3d is imported. Now, our plot looks like this:\nSince we are now plotting in three dimensions, we will also need to define three axes.\nz = np.linspace( 0 , 20 , 100 )\rx = np.sin(z)\ry = np.cos(z)\rax = plt.axes( projection = \u0026#39;3d\u0026#39; )\rax.plot3D(x,y,z)\rplt.show()\rIn this case, we are taking the z-axis as the input. The z-axis is the one which goes upwards. We define the x-axis and the y-axis to be a sine and cosine function. Then, we use the function plot3D to plot our function. We end up with this:\n\rSURFACE PLOTS\rNow in order to plot a function with a surface, we need to calculate every point on it. This is impossible, which is why we are just going to calculate enough to estimate the graph. In this case, x and y will be the input and the z-function will be the 3D-result which is composed of them.\nax = plt.axes( projection = \u0026#39;3d\u0026#39; )\rdef z_function(x, y):\rreturn np.sin(np.sqrt(x ** 2 + y ** 2 ))\rx = np.linspace(- 5 , 5 , 50 )\ry = np.linspace(- 5 , 5 , 50 )\rWe start by defining a z_function which is a combination of sine, square root and squaring the input. Our inputs are just 50 numbers from -5 to 5.\nX, Y = np.meshgrid(x,y)\rZ = z_function(X,Y)\rax.plot_surface(X,Y,Z)\rplt.show()\rThen we define new variables for x and y (we are using capitals this time). What we do is converting the x- and y-vectors into matrices using the meshgrid function. Finally, we use the z_function to calculate our z-values and then we plot our surface by using the method plot_surface\n\r\r",
    "ref": "/blog/numpy/"
  },{
    "title": "Python - Matplotlib",
    "date": "",
    "description": "Introduction to Matplotlib",
    "body": "\r\r\rMatplotlib\r\rPLOTTING MATHEMATICAL FUNCTIONS\rVISUALIZING VALUES\rMULTIPLE GRAPHS\rSUBPLOTS\rMULTIPLE PLOTTING WINDOWS\rPLOTTING STYLES\rLABELING DIAGRAMS\rSETTING TITLES\rLABELING AXES\rLEGENDS\rSAVING DIAGRAMS\r\r\r\rMatplotlib\rVisualizing our data is crucial for data science. It gives us an overview and helps us to analyze data and make conclusions. Matplotlib is the library which we use for plotting and visualizing.\nPLOTTING MATHEMATICAL FUNCTIONS\rNow first we will be drawing some mathematical functions.\nWe need importing the matplotlib.pyplot module and also NumPy.\nimport numpy as np\rimport matplotlib.pyplot as plt\rWe are also using alias for pyplot. In this case, it is plt .\rIn order to plot a function, we need the x-values or the input and the y-values or the output.\rSo first let us generate the x-values.\nx_values = np.linspace( 0 , 18 , 100 )\rWe wll be doing this by using the already known linspace function. Here we create an array with 100 values between 0 and 18. To now get our y-values, we just need to apply the respective function on our\nx-values. For this example, we are going with the sine function.\ny_values = np.sin(x_values)\rRemember that the function gets applied to every single item of the input array. So in this case, we have an array with the sine value of every element of the x-values array. We just need to plot them now.\nplt.plot(x_values, y_values)\rplt.show()\rWe do this by using the function plot and passing our x-values and y-values. At the end we call the show function, to display our plot.\nThat was very simple. Now, we can go ahead and define our own function that we want to plot.\nx = np.linspace( 0 , 10 , 100 )\ry = ( 6 * x - 30 ) ** 2\rplt.plot(x, y)\rplt.show()\rThe result looks like this:\nThis function (6x – 30)² is plotted with Matplotlib.\n\rVISUALIZING VALUES\rWhat we can also do, instead of plotting functions, is just visualizing values in form of single dots for example.\nnumbers = 10 * np.random.random( 100 )\rplt.plot(numbers, \u0026#39;bo\u0026#39; )\rplt.show()\rHere we generate 100 random numbers from 0 to 10. We then plot these numbers as blue dots. This is defined by the second parameter ‘bo’ , where the first letter indicates the color (blue) and the second one the shape (dots).\n\rMULTIPLE GRAPHS\rWe can plot multiple functions in different color and shape.\nx = np.linspace( 0 , 5 , 200 )\ry1 = 2 * x\ry2 = x ** 2\ry3 = np.log(x)\rplt.plot(x, y1)\rplt.plot(x, y2)\rplt.plot(x, y3)\rplt.show()\rIn this example, we first generate 200 x-values from 0 to 5. Then we define three different functions y1, y2 and y3 . We plot all these and view the plotting window. This is what it looks like:\n\rSUBPLOTS\rNow, sometimes we want to draw multiple graphs but we don’t want them in the same plot necessarily. For this reason, we have so-called subplots . These are plots that are shown in the same window but independently from each other.\nx = np.linspace( 0 , 5 , 200 )\ry1 = np.sin(x)\ry2 = np.sqrt(x)\rplt.subplot( 211 )\rplt.plot(x, y1, \u0026#39;r-\u0026#39; )\rplt.subplot( 212 )\rplt.plot(x, y2, \u0026#39;g--\u0026#39; )\rplt.show()\rBy using the function subplot we state that everything we plot now belongs to this specific subplot. The parameter we pass defines the grid of our window. The first digit indicates the number of rows, the second the number of columns and the last one the index of the subplot. So in this case, we have two rows and one column. Index one means that the respective subplot will be at the top.\nAs you can see, we have two subplots in one window and both have a different color and shape. Notice that the ratios between the x-axis and the y-axis differ in the two plots.\n\rMULTIPLE PLOTTING WINDOWS\rInstead of plotting into subplots, we can also go ahead and plot our graphs into multiple windows. In Matplotlib we call these figures .\nplt.figure( 1 )\rplt.plot(x, y1, \u0026#39;r-\u0026#39; )\rplt.figure( 2 )\rplt.plot(x, y2, \u0026#39;g--\u0026#39; )\rBy doing this, we can show two windows with their graphs at the same time. Also, we can use subplots within figures.\n\rPLOTTING STYLES\rIn order to use a style, we need to import the style module of Matplotlib and then call the function use .\nfrom matplotlib import style\rstyle.use( \u0026#39;ggplot\u0026#39; )\rBy using the from … import … notation we don’t need to specify the parent module matplotlib . Here we apply the style of ggplot . This adds a grid and some other design changes to our plots. For more information, check out the link above.\n\rLABELING DIAGRAMS\rIn order to make our graphs understandable, we need to label them properly. We should label the axes, we should give our windows titles and in some cases we should also add a legend.\n\rSETTING TITLES\rLet’s start out by setting the titles of our graphs and windows.\nx = np.linspace( 0 , 50 , 100 )\ry = np.sin(x)\rplt.title( \u0026#39;Sine Function\u0026#39; )\rplt.suptitle( \u0026#39;Data Science\u0026#39; )\rplt.grid( True )\rplt.plot(x,y)\rplt.show()\rIn this example, we used the two functions title and suptitle . The first function adds a simple title to our plot and the second one adds an additional centered title above it. Also, we used the grid function, to turn on the grid of our plot.\nIf you want to change the title of the window, you can use the figure function that we already know.\nplt.figure( \u0026#39;MyFigure\u0026#39; )\r\rLABELING AXES\rAs a next step, we are going to label our axes. For this, we use the two functions xlabel and ylabel .\nplt.xlabel( \u0026#39;x-values\u0026#39; )\rplt.ylabel( \u0026#39;y-values\u0026#39; )\rYou can choose whatever labels you like. When we combine all these pieces of code, we end up with a graph like this:\nIn this case, the labels aren’t really necessary because it is obvious what we see here. But sometimes we want to describe what our values actually mean and what the plot is about.\n\rLEGENDS\rSometimes we will have multiple graphs and objects in a plot. We then use legends to label these individual elements, in order to make everything more readable.\nx = np.linspace( 10 , 50 , 100 )\ry1 = np.sin(x)\ry2 = np.cos(x)\ry3 = np.log(x/ 3 )\rplt.plot(x,y1, \u0026#39;b-\u0026#39; , label = \u0026#39;Sine\u0026#39; )\rplt.plot(x,y2, \u0026#39;r-\u0026#39; , label = \u0026#39;Cosine\u0026#39; )\rplt.plot(x,y3, \u0026#39;g-\u0026#39; , label = \u0026#39;Logarithm\u0026#39; )\rplt.legend( loc = \u0026#39;upper left\u0026#39; )\rplt.show()\rHere we have three functions, sine , cosine and a logarithmic function. We draw all graphs into one plot and add a label to them. In order to make these labels visible, we then use the function legend and specify a location for it. Here we chose the upper left . Our result looks like this:\n\rSAVING DIAGRAMS\rSo now that we know quite a lot about plotting and graphing, let’s take a look at how to save our diagrams.\nplt.savefig( \u0026#39;functions.png\u0026#39; )\rActually, this is quite simple. We just plot whatever we want to plot and then use the function savefig to save our figure into an image file.\n\r\r",
    "ref": "/blog/matplotlib/"
  },{
    "title": "Python - Numpy",
    "date": "",
    "description": "Introduction to Numpy",
    "body": "\r\r\rNUMPY ARRAYS\r\rCREATING ARRAYS\rMULTI-DIMENSIONAL ARRAYS\rFILLING ARRAYS\rFULL FUNCTION\rZEROS AND ONES\rEMPTY AND RANDOM\rRANGES\rNOT A NUMBER (NAN)\rATTRIBUTES OF ARRAYS\rMATHEMATICAL OPERATIONS\rARITHMETIC OPERATIONS\rMATHEMATICAL FUNCTIONS\rAGGREGATE FUNCTIONS\rMANIPULATING ARRAYS\r\rSHAPE MANIPULATION FUNCTIONS\r\rJOINING FUNCTIONS\r\rSPLITTING FUNCTIONS\r\rADDING AND REMOVING\rLOADING AND SAVING ARRAYS\rNUMPY FORMAT\rCSV FORMAT\r\r\r\rNUMPY ARRAYS\rWe can’t do a lot of data science with NumPy alone. But it provides the basis for all the high-level libraries or modules for data science. It is essential for the efficient management of arrays and linear algebra.\nIn order to use NumPy, we of course have to import the respective module first.\nimport numpy as np\rAs you can see, we are also defining an alias here, so that we can address NumPy by just writing np .\nCREATING ARRAYS\rTo create a NumPy array, we just use the respective function array and pass a list to it.\na = np.array([ 10 , 20 , 30 ])\rb = np.array([ 1 , 77 , 2 , 3 ])\rNow we can access the values in the same way as we would do it with a list.\nprint (a[ 0 ])\r## 10\rprint (b[ 2 ])\r## 2\r\rMULTI-DIMENSIONAL ARRAYS\rThe arrays we created are one-dimensional arrays. With NumPy, we can create large multi-dimensional arrays that have the same structure as a matrix.\na = np.array([\r[ 10 , 20 , 30 ],\r[ 40 , 50 , 60 ]\r])\rprint (a)\r## [[10 20 30]\r## [40 50 60]]\rHere, we pass two lists within a list as a parameter. This creates a 2x3 matrix. When we print the array, we get the following result:\n[[10 20 30]\r[40 50 60]]\nSince we now have two dimensions, we also need to address two indices, in order to access a specific element.\nprint (a[ 1 ][ 2 ])\r## 60\rIn this case, we are addressing the second row (index one) and the third element or column (index two). Therefore, our result is 60 .\rWe can extend this principle as much as we want. For example, let’s create a much bigger array.\na = np.array([\r[\r[ 10 , 20 , 30 , 40 ], [ 8 , 8 , 2 , 1 ], [ 1 , 1 , 1 , 2 ]\r],\r[\r[ 9 , 9 , 2 , 39 ], [ 1 , 2 , 3 , 3 ], [ 0 , 0 , 3 , 2 ]\r],\r[\r[ 12 , 33 , 22 , 1 ], [ 22 , 1 , 22 , 2 ], [ 0 , 2 , 3 , 1 ]\r]\r], dtype = float )\rHere we have a 3x3x4 matrix and slowly but surely it becomes a bit irritating and we can’t really grasp the structure of the array. This is especially the case when we get into four or more dimensions, since we only perceive three dimensions in everyday life.\nYou can imagine this three-dimensional array as a cube. We have three rows, four columns and three pages or layers. Such visualizations fail in higher dimensions.\nAnother thing that is worth mentioning is the parameter dtype . It stands for data type and allows us to specify which data type our values have. In this case we specified float and therefore our values will be stored as floating point numbers with the respective notation.\n\rFILLING ARRAYS\rInstead of manually filling our arrays with values, we can also use pre-defined functions in certain cases. The only thing we need to specify is the desired function and the shape of the array.\n\rFULL FUNCTION\rBy using the full function for example, we fill an array of a certain shape with the same number. In this case we create a 3x5x4 matrix, which is filled with sevens.\na = np.full(( 3 , 5 , 4 ), 7 )\rprint (a)\r## [[[7 7 7 7]\r## [7 7 7 7]\r## [7 7 7 7]\r## [7 7 7 7]\r## [7 7 7 7]]\r## ## [[7 7 7 7]\r## [7 7 7 7]\r## [7 7 7 7]\r## [7 7 7 7]\r## [7 7 7 7]]\r## ## [[7 7 7 7]\r## [7 7 7 7]\r## [7 7 7 7]\r## [7 7 7 7]\r## [7 7 7 7]]]\r\rZEROS AND ONES\rFor the cases that we want arrays full of zeros or ones, we even have specific functions.\na = np.zeros(( 3 , 3 ))\rb = np.ones(( 2 , 3 , 4 , 2 ))\rHere we create a 3x3 array full of zeros and a four-dimensional array full of ones.\n\rEMPTY AND RANDOM\rOther options would be to create an empty array or one that is filled with random numbers. For this, we use the respective functions once again.\na = np.empty(( 4 , 4 ))\rb = np.random.random(( 2 , 3 ))\rThe function empty creates an array without initializing the values at all. This makes it a little bit faster but also more dangerous to use, since the user needs to manually initialize all the values.\nWhen using the random function, make sure that you are referring to the module np.random . You need to write it two times because otherwise you are calling the library.\n\rRANGES\rInstead of just filling arrays with the same values, we can fill create sequences of values by specifying the boundaries. For this, we can use two different functions, namely arange and linspace .\na = np.arange( 10 , 50 , 5 )\rThe function arange creates a list with values that range from the minimum to the maximum. The step-size has to be specified in the parameters.\n[10 15 20 25 30 35 40 45]\nIn this example, we create have count from 10 to 45 by always adding 5. The result can be seen above.\nBy using linspace we also create a list from a minimum value to a maximum value. But instead of specifying the step-size, we specify the amount of values that we want to have in our list. They will all be spread evenly and have the same distance to their neighbors.\nb = np.linspace( 0 , 100 , 11 )\rHere, we want to create a list that ranges from 0 to 100 and contains 11 elements. This fits smoothly with a difference of 10 between all numbers. So the result looks like this:\n[ 0. 10. 20. 30. 40. 50. 60. 70. 80. 90. 100.]\nOf course, if we choose different parameters, the numbers don’t be that “beautiful”.\n\rNOT A NUMBER (NAN)\rThere is a special value in NumPy that represents values that are not numbers. It is called NaN and stands for Not a Number . We basically just use it as a placeholder for empty spaces. It can be seen as a value that indicates that something is missing at that place.\nWhen importing big data packets into our application, there will sometimes be missing data. Instead of just setting these values to zero or something else, we can set them to NaN and then filter these data sets out.\n\rATTRIBUTES OF ARRAYS\rNumPy arrays have certain attributes that we can access and that provide information about the structure of it.\n\r\rUMPY ARRAY ATTRIBUTES\r\r\r\r\ra.shape\rReturns the shape of the array\r\r\re.g. (3,3) or (3,4,7)\r\ra.ndim\rReturns how many dimensions our array has\r\ra.size\rReturns the amount of elements an array has\r\ra.dtype\rReturns the data type of the values in the array\r\r\r\r\rMATHEMATICAL OPERATIONS\rNow that we know how to create an array and what attributes it has, let’s take a look at how to work with arrays. For this, we will start out with basic mathematical operations.\n\rARITHMETIC OPERATIONS\ra = np.array([\r[ 1 , 4 , 2 ],\r[ 8 , 8 , 2 ]\r])\rprint (a + 2 )\r## [[ 3 6 4]\r## [10 10 4]]\rprint (a - 2 )\r## [[-1 2 0]\r## [ 6 6 0]]\rprint (a * 2 )\r## [[ 2 8 4]\r## [16 16 4]]\rprint (a / 2 )\r## [[0.5 2. 1. ]\r## [4. 4. 1. ]]\rWhen we perform basic arithmetic operations like addition, subtraction, multiplication and division to an array and a scalar, we apply the operation on every single element in the array. Let’s take a look at the results:\n[[ 3 6 4]\r[10 10 4]]\r[[-1 2 0]\r[ 6 6 0]]\r[[ 2 8 4]\r[16 16 4]]\r[[0.5 2. 1. ]\r[4. 4. 1. ]]\nAs you can see, when we multiply the array by two, we multiply every single value in it by two. This is also the case for addition, subtraction and division. But what happens when we apply these operations on two arrays?\na = np.array([\r[ 1 , 4 , 2 ],\r[ 8 , 8 , 2 ]\r])\rb = np.array([\r[ 1 , 2 , 3 ]\r])\rc = np.array([\r[ 1 ],\r[ 2 ]\r])\rd = np.array([\r[ 1 , 2 , 3 ],\r[ 3 , 2 , 1 ]\r]) \rIn order to apply these operations on two arrays, we need to take care of the shapes. They don’t have to be the same, but there has to be a reasonable way of performing the operations. We then again apply the operations on each element of the array.\nFor example, look at a and b . They have different shapes but when we add these two, they share at least the amount of columns.\nprint (a+b)\r## [[ 2 6 5]\r## [ 9 10 5]]\r[[ 2 6 5]\r[ 9 10 5]]\nSince they match the columns, we can just say that we add the individual columns, even if the amount of rows differs.\rThe same can also be done with a and c where the rows match and the columns differ.\nprint (a+c)\r## [[ 2 5 3]\r## [10 10 4]]\r[[ 2 5 3]\r[10 10 4]]\nAnd of course it also works, when the shapes match exactly. The only problem is when the shapes differ too much and there is no reasonable way of performing the operations. In these cases, we get ValueErrors .\n\rMATHEMATICAL FUNCTIONS\rAnother thing that the NumPy module offers us is mathematical functions that we can apply to each value in an array.\n\r\rNUMPY MATHEMATICAL FUNCTIONS\r\r\r\r\rnp.exp(a)\rTakes e to the power of each value\r\rnp.sin(a)\rReturns the sine of each value\r\rnp.cos(a)\rReturns the cosine of each value\r\rnp.tan(a)\rReturns the tangent of each value\r\rnp.log(a)\rReturns the logarithm of each value\r\rnp.sqrt(a)\rReturns the square root of each value\r\r\r\r\rAGGREGATE FUNCTIONS\rNow we are getting into the statistics. NumPy offers us some so-called aggregate functions that we can use in order to get a key statistic from all of our values.\n\r\rNUMPY AGGREGATE FUNCTIONS\r\r\r\r\ra.sum()\rReturns the sum of all values in the array\r\ra.min()\rReturns the lowest value of the array\r\ra.max()\rReturns the highest value of the array\r\ra.mean()\rReturns the arithmetic mean of all values in the array\r\rnp.median(a)\rReturns the median value of the array\r\rnp.std(a)\rReturns the standard deviation of the values in the array\r\r\r\r\rMANIPULATING ARRAYS\rNumPy offers us numerous ways in which we can manipulate the data of our arrays. Here, we are going to take a quick look at the most important functions and categories of functions.\rIf you just want to change a single value however, you can just use the basic indexing of lists.\na = np.array([\r[ 4 , 2 , 9 ],\r[ 8 , 3 , 2 ]\r])\ra[ 1 ][ 2 ] = 7 \rSHAPE MANIPULATION FUNCTIONS\rOne of the most important and helpful types of functions are the shape manipulating functions . These allow us to restructure our arrays without changing their values.\n\r\r\r\rSHAPE MANIPULATION FUNCTIONS\r\r\r\r\ra.reshape(x,y)\rReturns an array with the same values structured in a different shape\r\ra.flatten()\rReturns a flattened one-dimensional copy of the array\r\ra.ravel()\rDoes the same as flatten but works with the actual array instead of a copy\r\ra.transpose()\rReturns an array with the same values but swapped dimensions\r\ra.swapaxes()\rReturns an array with the same values but two swapped axes\r\ra.flat\rNot a function but an iterator for the flattened version of the array\r\r\r\rThere is one more element that is related to shape but it’s not a function. It is called flat and it is an iterator for the flattened one-dimensional version of the array. Flat is not callable but we can iterate over it with for loops or index it.\nfor x in a.flat:\rprint (x)\r## 4\r## 2\r## 9\r## 8\r## 3\r## 7\rprint (a.flat[ 5 ])\r## 7\r\r\rJOINING FUNCTIONS\rWe use joining functions when we combine multiple arrays into one new array.\n\r\rJOINING FUNCTIONS\r\r\r\r\rFUNCTION\rDESCRIPTION\r\rnp.concatenate(a,b)\rJoins multiple arrays along an existing axis\r\rnp.stack(a,b)\rJoins multiple arrays along a new axis\r\rnp.hstack(a,b)\rStacks the arrays horizontally (column-wise)\r\rnp.vstack(a,b)\rStacks the arrays vertically\r\r\r(row-wise)\r\r\r\rIn the following, you can see the difference between concatenate and stack :\na = np.array([ 10 , 20 , 30 ])\rb = np.array([ 20 , 20 , 10 ])\rprint (np.concatenate((a,b)))\r## [10 20 30 20 20 10]\rprint (np.stack((a,b)))\r## [[10 20 30]\r## [20 20 10]]\r[10 20 30 20 20 10]\r[[10 20 30]\r[20 20 10]]\nWhat concatenate does is, it joins the arrays together by just appending one onto the other. Stack on the other hand, creates an additional axis that separates the two initial arrays.\nSPLITTING FUNCTIONS\rWe can not only join and combine arrays but also split them again. This is done by using splitting functions that split arrays into multiple sub-arrays.\n\r\r\r\rSPLITTING FUNCTIONS\r\r\r\r\rnp.split(a, x)\rSplits one array into multiple arrays\r\rnp.hsplit(a, x)\rSplits one array into multiple arrays horizontally (column-wise)\r\rnp.vsplit(a, x)\rSplits one array into multiple arrays vertically (row-wise)\r\r\r\rWhen splitting a list with the split function, we need to specify into how many sections we want to split our array.\na = np.array([\r[ 10 , 20 , 30 ],\r[ 40 , 50 , 60 ],\r[ 70 , 80 , 90 ],\r[ 100 , 110 , 120 ]\r])\rprint (np.split(a, 2 ))\r## [array([[10, 20, 30],\r## [40, 50, 60]]), array([[ 70, 80, 90],\r## [100, 110, 120]])]\rprint (np.split(a, 4 ))\r## [array([[10, 20, 30]]), array([[40, 50, 60]]), array([[70, 80, 90]]), array([[100, 110, 120]])]\rThis array can be split into either two or four equally sized arrays on the default axis. The two possibilities are the following:\n1: [[10, 20, 30],[40, 50, 60]]\r2: [[70, 80, 90],[100, 110, 120]]\nOR\n1: [[10, 20, 30]]\r2: [[40, 50, 60]]\r3: [[70, 80, 90]]\r4: [[100, 110, 120]]\n\r\rADDING AND REMOVING\rThe last manipulating functions that we are going to look at are the ones which allow us to add and to remove items.\n\r\r\r\rADDING AND REMOVING FUNCTIONS\r\r\r\r\rnp.resize(a, (x,y))\rReturns a resized version of the array and fills empty spaces by repeating copies of a\r\rnp.append(a, […])\rAppends values at the end of the array\r\rnp.insert(a, x, …)\rInsert a value at the index x of the array\r\rnp.delete(a, x, y)\rDelete axes of the array\r\r\r\r\rLOADING AND SAVING ARRAYS\rNow last but not least, we are going to talk about loading and saving NumPy arrays. For this, we can use the integrated NumPy format or CSV-files.\n\rNUMPY FORMAT\rBasically, we are just serializing the object so that we can use it later. This is done by using the save function.\na = np.array([\r[ 10 , 20 , 30 ],\r[ 40 , 50 , 60 ],\r[ 70 , 80 , 90 ],\r[ 100 , 110 , 120 ]\r])\rnp.save( \u0026#39;myarray.npy\u0026#39; , a)\rNotice that you don’t have to use the file ending npy . In this example, we just use it for clarity. You can pick whatever you want.\rNow, in order to load the array into our script again, we will need the load function.\na = np.load( \u0026#39;myarray.npy\u0026#39; )\rprint (a)\r\rCSV FORMAT\rAs I already mentioned, we can also save our NumPy arrays into CSV files, which are just comma-separated text files. For this, we use the function savetxt .\nnp.savetxt( \u0026#39;myarray.csv\u0026#39; , a)\rOur array is now stored in a CSV-file which is very useful, because it can then also be read by other applications and scripts.\nIn order to read this CSV-file back into our script, we use the function loadtxt .\na = np.loadtxt( \u0026#39;myarray.csv\u0026#39; )\rprint (a)\rIf we want to read in a CSV-file that uses another separator than the default one, we can specify a certain delimiter.\na = np.loadtxt( \u0026#39;myarray.csv\u0026#39; , delimiter = \u0026#39;;\u0026#39; )\rprint (a)\rNow it uses semi-colons as separator when reading the file. The same can also be done with the saving or writing function\n\r\r",
    "ref": "/blog/numpy/"
  },{
    "title": "À propos de",
    "date": "",
    "description": "Hugo, le framework le plus rapide au monde pour la création de sites Web",
    "body": "Écrit dans Go, Hugo est un générateur de site statique open source disponible sous la [Apache License 2.0.] (Https://github.com/gohugoio/hugo/blob/master/LICENSE) Hugo prend en charge les types de fichiers de données TOML, YAML et JSON , Markdown et fichiers de contenu HTML et utilise des shortcodes pour ajouter du contenu riche. Les autres fonctionnalités notables sont les taxonomies, le mode multilingue, le traitement d\u0026rsquo;image, les formats de sortie personnalisés, la minification HTML / CSS / JS et la prise en charge des flux de travail Sass SCSS.\nHugo utilise une variété de projets open source, notamment:\n https://github.com/yuin/goldmark https://github.com/alecthomas/chroma https://github.com/muesli/smartcrop https://github.com/spf13/cobra https://github.com/spf13/viper  Hugo est idéal pour les blogs, les sites Web d\u0026rsquo;entreprise, les portefeuilles créatifs, les magazines en ligne, les applications d\u0026rsquo;une seule page ou même un site Web avec des milliers de pages.\nHugo est destiné aux personnes qui souhaitent coder manuellement leur propre site Web sans se soucier de la mise en place d\u0026rsquo;exécutions complexes, de dépendances et de bases de données.\nLes sites Web construits avec Hugo sont extrêmement rapides, sécurisés et peuvent être déployés n\u0026rsquo;importe où, y compris AWS, GitHub Pages, Heroku, Netlify et tout autre fournisseur d\u0026rsquo;hébergement.\nEn savoir plus et contribuer sur [GitHub] (https://github.com/gohugoio).\n",
    "ref": "/about/"
  },{
    "title": "Python - Regular Expressions",
    "date": "",
    "description": "Introduction to Regular Expressions",
    "body": "\r\r\rREGULAR EXPRESSIONS\r\rIDENTIFIER\rMODIFIER\rESCAPE CHARACTERS\rAPPLYING REGULAR EXPRESSIONS\rMATCHING STRINGS\r\rMANIPULATING STRINGS\r\r\r\r\rREGULAR EXPRESSIONS\rIn programming, you will oftentimes have to deal with long texts from which we want to extract specific information. Also, when we want to process certain inputs, we need to check for a specific pattern. For example, think about emails. They need to have some text, followed by an @ character, then again some text and finally a dot and again some little text.\nIn order to make the validations easier, more efficient and more compact, we use so-called regular expressions .\nThe topic of regular expressions is very huge and you could write a whole book only about it. This is why we are not going to focus too much on the various placeholders and patterns of the expressions themselves but on the implementation of RegEx in Python.\rSo in order to confuse you right in the beginning, let’s look at a regular expression that checks if the format of an email-address is valid.\n^[a-zA-Z0-9.!#$%\u0026amp;\u0026#39;*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$\rNow you can see why this is a huge field to learn. In this chapter, we are not going to build regular expressions like this. We are going to focus on quite simple examples and how to properly implement them in Python.\nIDENTIFIER\rLet’s get started with some basic knowledge first. So-called identifiers define what kind of\rcharacter should be at a certain place. Here you have some examples:\n| |REGEX IDENTIFIERS | |\r|--------------------|--------------------------------------|\r| IDENTIFIER | DESCRIPTION |\r| \\d | Some digit |\r| \\D | Everything BUT a digit |\r| \\s | White space |\r| \\S | Everything BUT a white space |\r| \\w | Some letter |\r| \\W | Everything BUT a letter |\r| . | Every character except for new lines |\r| \\b | White spaces around a word |\r| \\. | A dot |\r\rMODIFIER\rThe modifiers extend the regular expressions and the identifiers. They might be seen as some kind of operator for regular expressions.\n| REGEX MODIFIERS | |\r|-----------------|--------------------------------------------|\r| MODIFIER | DESCRIPTION |\r| {x,y} | A number that has a length between x and y |\r| + | At least one |\r| ? | None or one |\r| * | Everything |\r| $ | At the end of a string |\r| ^ | At the beginning of a string |\r| | | Either Or |\r| | Example: x | y = either x or y |\r| [] | Value range |\r| {x} | x times |\r| {x,y} | x to y times |\r\rESCAPE CHARACTERS\r| REGEX ESCAPE CHARATCERS | |\r|-------------------------|-------------|\r| CHARACTER | DESCRIPTION |\r| \\n | New Line |\r| \\t | Tab |\r| \\s | White Space |\r\rAPPLYING REGULAR EXPRESSIONS\rFINDING STRINGS\nIn order to apply these regular expressions in Python, we need to import the module re .\nimport re\rNow we can start by trying to find some patterns in our strings.\ntext = \u0026#39;\u0026#39;\u0026#39;\rMike is 20 years old and George is 29!\rMy grandma is even 104 years old!\r\u0026#39;\u0026#39;\u0026#39;\rages = re.findall( r\u0026#39;\\d{1,3}\u0026#39; , text)\rprint (ages)\r## [\u0026#39;20\u0026#39;, \u0026#39;29\u0026#39;, \u0026#39;104\u0026#39;]\rIn this example, we have a text with three ages in it. What we want to do is to filter these out and print them separately.\nAs you can see, we use the function findall in order to apply the regular expression onto our string. In this case, we are looking for numbers that are one to three digits long. Notice that we are using an r character before we write our expression. This indicates that the given string is a regular expression.\nAt the end, we print our result and get the following output:\n[‘20’, ‘29’, ‘104’]\n\rMATCHING STRINGS\rWhat we can also do is to check if a string matches a certain regular expression. For example, we can apply our regular expression for mails here.\nimport re\rtext = \u0026#39;test@mail.com\u0026#39;\rresult = re.fullmatch( r\u0026#39;^[a-zA-Z0-9.!#$%\u0026amp;\u0026#39;*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$\u0026#39; , text)\rif result != None :\rprint ( \u0026#39;VALID!\u0026#39; )\relse :\rprint ( \u0026#39;INVALID!\u0026#39; )\rWe are not going to talk about the regular expression itself here. It is very long and complicated. But what we see here is a new function called fullmatch . This function returns the checked string if it matches the regular expression. In this case, this happens when the string has a valid mail format.\nIf the expression doesn’t match the string, the function returns None . In our example above, we get the message “VALID!” since the expression is met. If we enter something like “Hello World!”, we will get the other message.\nMANIPULATING STRINGS\rFinally, we are going to take a look at manipulating strings with regular expressions. By using the function sub we can replace all the parts of a string that match the expression by something else.\nimport re\rtext = \u0026#39;\u0026#39;\u0026#39;\rMike is 20 years old and George is 29!\rMy grandma is even 104 years old!\r\u0026#39;\u0026#39;\u0026#39;\rtext = re.sub( r\u0026#39;\\d{1,3}\u0026#39; , \u0026#39;100\u0026#39; , text)\rprint (text)\r## ## Mike is 100 years old and George is 100!\r## My grandma is even 100 years old!\rIn this example, we replace all ages by 100 . This is what gets printed:\rMike is 100 years old and George is 100!\rMy grandma is even 100 years old!\nThese are the basic functions that we can operate with in Python when dealing with regular expressions. If you want to learn more about regular expressions just google and you will find a lot of guides. Play around with the identifiers and modifiers a little bit until you feel like you understand how they work.\n\r\r\r",
    "ref": "/blog/regular-expressions/"
  },{
    "title": "Python - Logging",
    "date": "",
    "description": "Introduction to Python Logging",
    "body": "\r\r\rLOGGING\r\rSECURITY LEVELS\rCREATING LOGGERS\rLOGGING INTO FILES\rFORMATTING LOGS\r\r\r\rLOGGING\rNo matter what we do in computer science, sooner or later we will need logs. Every system that has a certain size produces errors or conditions in which specific people should be warned or informed. Nowadays, everything gets logged or recorded. Bank transactions, flights, networking activities, operating systems and much more. Log files help us to find problems and to get information about the state of our systems. They are an essential tool for avoiding and understanding errors.\rUp until now, we have always printed some message onto the console screen when we encountered an error. But when our applications grow, this becomes confusing and we need to categorize and outsource our logs. In addition, not every message is equally relevant. Some messages are urgent because a critical component fails and some just provide nice information.\nSECURITY LEVELS\rIn Python, we have got five security levels. A higher level means higher importance or urgency.\n\rDEBUG\rINFO\rWARNING\rERROR\rCRITICAL\n\rNotice that when we choose a certain security level, we also get all the messages of the levels above. So for example, INFO also prints the messages of WARNING, ERROR and CRITICAL but not of DEBUG .\rDEBUG is mainly used for tests, experiments or in order to check something. We typically use this mode, when we are looking for errors (troubleshooting).\rWe use INFO when we want to log all the important events that inform us about what is happening. This might be something like “User A logged in successfully!” or “Now we have 17 users online!”\rWARNING messages are messages that inform us about irregularities and things that might go wrong and become a problem. For example messages like “Only 247 MB of RAM left!”\rAn ERROR message gets logged or printed when something didn’t go according to the plan. When we get an exception this is a classical error.\rCRITICAL messages tell us that critical for the whole system or application happened. This might be the case when a crucial component fails and we have to immediately stop all operations.\n\rCREATING LOGGERS\rIn order to create a logger in Python, we need to import the logging module.\nimport logging\rNow we can just log messages by directly using the respective functions of the logging module.\nlogging.info( \u0026#39;First informational message!\u0026#39; )\rlogging.critical( \u0026#39;This is serious!\u0026#39; )\rThis works because we are using the root logger. We haven’t created our own loggers yet. The output looks like this:\nCRITICAL:root:This is serious!\nINFO:root:Logger successfully created!\nSo let’s create our own logger now. This is done by either using the constructor of the Logger class or by using the method getLogger .\nlogger = logging.getLogger()\rlogger = logging.Logger( \u0026#39;MYLOGGER\u0026#39; )\rNotice that we need to specify a name for our logger, if we use the constructor. Now we can log our messages.\nlogger.info( \u0026#39;Logger successfully created!\u0026#39; )\rlogger.log(logging.INFO, \u0026#39;Successful!\u0026#39; )\rlogger.critical( \u0026#39;Critical Message!\u0026#39; )\rlogger.log(logging.CRITICAL, \u0026#39;Critical!\u0026#39; )\rHere we also have two different options for logging messages. We can either directly call the function of the respective security level or we can use the method log and specify the security level in the parameters.\nBut when you now execute the script, you will notice that it will only print the critical messages. This has two reasons. First of all, we need to adjust the level of the logger and second of all, we need to remove all of the handlers from the default root logger.\nfor handler in logging.root.handlers:\nlogging.root.removeHandler(handler)\rlogging.basicConfig( level =logging.INFO)\rHere we just use a for loop in order to remove all the handlers from the root logger. Then we use the basicConfig method, in order to set our logging level to INFO . When we now run our code again, the output is the following:\nINFO:MYLOGGER:Logger successfully created!\rINFO:MYLOGGER:Successful!\rCRITICAL:MYLOGGER:Critical Message!\rCRITICAL:MYLOGGER:Critical!\n\rLOGGING INTO FILES\rWhat we are mainly interested in is logging into files. For this, we need a so-called FileHandler . It is an object that we add to our logger, in order to make it log everything into a specific file.\nimport logging\rlogger = logging.getLogger( \u0026#39;MYLOGGER\u0026#39; )\rlogger.setLevel(logging.INFO)\rhandler = logging.FileHandler( \u0026#39;logfile.log\u0026#39; )\rhandler.setLevel(logging.INFO)\rlogger.addHandler(handler)\rlogger.info( \u0026#39;Log this into the file!\u0026#39; )\rlogger.critical( \u0026#39;This is critical!\u0026#39; )\rWe start again by defining a logger. Then we set the security level to INFO by using the function setLevel . After that, we create a FileHandler that logs into the file logfile.log . Here we also need to set the security level. Finally, we add the handler to our logger using the addHandler function and start logging messages.\n\rFORMATTING LOGS\rOne thing that you will notice is that we don’t have any format in our logs. We don’t know which logger was used or which security level our message has. For this, we can use a so-called formatter .\nimport logging\rlogger = logging.getLogger()\rlogger.setLevel(logging.INFO)\rhandler = logging.FileHandler( \u0026#39;logfile.log\u0026#39; )\rhandler.setLevel(logging.INFO)\rformatter = logging.Formatter( \u0026#39;%(asctime)s: %(levelname)s - %(message)s\u0026#39; )\rhandler.setFormatter(formatter)\rlogger.addHandler(handler)\rlogger.info( \u0026#39;This will get into the file!\u0026#39; )\rWe create a formatter by using the constructor of the respective class. Then we use the keywords for the timestamp, the security level name and the message. Last but not least, we assign the formatter to our handler and start logging again. When we now look into our file, we will find a more detailed message.\r2019-06-25 15:41:43,523: INFO - This will get into the file!\rThese log messages can be very helpful, if they are used wisely. Place them wherever something important or alarming happens in your code\n\r\r",
    "ref": "/blog/python-logging/"
  },{
    "title": "Python - XML Processing",
    "date": "",
    "description": "Introduction to Python XML Processing",
    "body": "\r\r\rXML PROCESSING\r\rXML PARSER\rSIMPLE API FOR XML (SAX)\rDOCUMENT OBJECT MODEL (DOM)\rXML STRUCTURE\rXML WITH SAX\rCONTENT HANDLER CLASS\rPROCESSING XML DATA\rXML WITH DOM\rMANIPULATING XML FILES\rCREATING NEW ELEMENTS\r\r\r\rXML PROCESSING\rUp until now, we either saved our data into regular text files or into professional databases. Sometimes however, our script is quite small and doesn’t need a big database but we still want to structure our data in files. For this, we can use XML .\nXML stands for Extensible Markup Language and is a language that allows us to hierarchically structure our data in files. It is platform-independent and also application-independent. XML files that you create with a Python script, can be read and processed by a C++ or Java application.\nXML PARSER\rIn Python, we can choose between two modules for parsing XML files – SAX and DOM .\n\rSIMPLE API FOR XML (SAX)\rSAX stands for Simple API for XML and is better suited for large XML files or in situations where we have very limited RAM memory space. This is because in this mode we never load the full file into our RAM. We read the file from our hard drive and only load the little parts that we need right at the moment into the RAM. An additional effect of this is that we can only read from the file and not manipulate it and change values.\n\rDOCUMENT OBJECT MODEL (DOM)\rDOM stands for Document Object Model and is the generally recommended option. It is a language-independent API for working with XML. Here we always load the full XML file into our RAM and then save it there in a hierarchical structure. Because of that, we can use all of the features and also manipulate the file.\nObviously, DOM is a lot faster than SAX because it is using the RAM instead of the hard disk. The main memory is way more efficient than the hard drive. We only use SAX when our RAM is so limited that we can’t even load the full XML file into it without problems.\rThere is no reason to not use both options in the same projects. We can choose depending on the use case.\n\rXML STRUCTURE\rFor this chapter, we are going to use the following XML file:\n\u0026lt;? xml version= \u0026#39;1.0\u0026#39; ?\u0026gt;\r\u0026lt; group \u0026gt;\r\u0026lt; person id= \u0026#39;1\u0026#39; \u0026gt;\r\u0026lt; name \u0026gt;John Smith\u0026lt;/ name \u0026gt;\r\u0026lt; age \u0026gt;20\u0026lt;/ age \u0026gt;\r\u0026lt; weight \u0026gt;80\u0026lt;/ weight \u0026gt;\r\u0026lt; height \u0026gt;188\u0026lt;/ height \u0026gt;\r\u0026lt;/ person \u0026gt;\r\u0026lt; person id= \u0026#39;2\u0026#39; \u0026gt;\r\u0026lt; name \u0026gt;Mike Davis\u0026lt;/ name \u0026gt;\r\u0026lt; age \u0026gt;45\u0026lt;/ age \u0026gt;\r\u0026lt; weight \u0026gt;82\u0026lt;/ weight \u0026gt;\r\u0026lt; height \u0026gt;185\u0026lt;/ height \u0026gt;\r\u0026lt;/ person \u0026gt;\r\u0026lt; person id= \u0026#39;3\u0026#39; \u0026gt;\r\u0026lt; name \u0026gt;Anna Johnson\u0026lt;/ name \u0026gt;\r\u0026lt; age \u0026gt;33\u0026lt;/ age \u0026gt;\r\u0026lt; weight \u0026gt;67\u0026lt;/ weight \u0026gt;\r\u0026lt; height \u0026gt;167\u0026lt;/ height \u0026gt;\r\u0026lt;/ person \u0026gt;\r\u0026lt; person id= \u0026#39;4\u0026#39; \u0026gt;\r\u0026lt; name \u0026gt;Bob Smith\u0026lt;/ name \u0026gt;\r\u0026lt; age \u0026gt;60\u0026lt;/ age \u0026gt;\r\u0026lt; weight \u0026gt;70\u0026lt;/ weight \u0026gt;\r\u0026lt; height \u0026gt;174\u0026lt;/ height \u0026gt;\r\u0026lt;/ person \u0026gt;\r\u0026lt; person id= \u0026#39;5\u0026#39; \u0026gt;\r\u0026lt; name \u0026gt;Sarah Pitt\u0026lt;/ name \u0026gt;\r\u0026lt; age \u0026gt;12\u0026lt;/ age \u0026gt;\r\u0026lt; weight \u0026gt;50\u0026lt;/ weight \u0026gt;\r\u0026lt; height \u0026gt;152\u0026lt;/ height \u0026gt;\r\u0026lt;/ person \u0026gt;\r\u0026lt;/ group \u0026gt; \rAs you can see, the structure is quite simple. The first row is just a notation and indicates that we are using XML version one. After that we have various tags. Every tag that gets opened also gets closed at the end.\rBasically, we have one group tag. Within that, we have multiple person tags that all have the attribute id . And then again, every person has four tags with their values. These tags are the attributes of the respective person. We save this file as group.xml .\n\rXML WITH SAX\rIn order to work with SAX, we first need to import the module:\nimport xml.sax\rNow, what we need in order to process the XML data is a content handler . It handles and processes the attributes and tags of the file.\nimport xml.sax\rhandler = xml.sax.ContentHandler()\rparser = xml.sax.make_parser()\rparser.setContentHandler(handler)\rparser.parse( \u0026#39;group.xml\u0026#39; )\rFirst we create an instance of the ContentHandler class. Then we use the method make_parser, in order to create a parser object. After that, we set our handler to the content handler of our parser. We can then parse the file by using the method parse .\nNow, when we execute our script, we don’t see anything. This is because we need to define what happens when an element gets parsed.\n\rCONTENT HANDLER CLASS\rFor this, we will define our own content handler class. Let’s start with a very simple example.\nimport xml.sax\rclass GroupHandler(xml.sax.ContentHandler):\rdef startElement( self , name, attrs):\rprint (name)\rhandler = GroupHandler()\rparser = xml.sax.make_parser()\rparser.setContentHandler(handler)\rparser.parse( \u0026#39;group.xml\u0026#39; )\rWe created a class GroupHandler that inherits from ContentHandler . Then we overwrite the function startElement . Every time an element gets processed, this function gets called. So by manipulating it, we can define what shall happen during the parsing process.\nNotice that the function has two parameters – name and attr . These represent the tag name and the attributes. In our simple example, we just print the tag names. So, let’s get to a more interesting example.\n\rPROCESSING XML DATA\rThe following example is a bit more complex and includes two more functions.\nimport xml.sax\rclass GroupHandler(xml.sax.ContentHandler):\rdef startElement( self , name, attrs):\rself .current = name\rif self .current == \u0026#39;person\u0026#39; :\rprint ( \u0026#39;--- Person ---\u0026#39; )\rid = attrs[ \u0026#39;id\u0026#39; ]\rprint ( \u0026#39;ID: %s\u0026#39; % id)\rdef endElement( self , name):\rif self .current == \u0026#39;name\u0026#39; :\rprint ( \u0026#39;Name: %s\u0026#39; % self .name)\relif self .current == \u0026#39;age\u0026#39; :\rprint ( \u0026#39;Age: %s\u0026#39; % self .age)\relif self .current == \u0026#39;weight\u0026#39; :\rprint ( \u0026#39;Weight: %s\u0026#39; % self .weight)\relif self .current == \u0026#39;height\u0026#39; :\rprint ( \u0026#39;Height: %s\u0026#39; % self .height)\rself .current = \u0026#39;\u0026#39; def characters( self , content):\rif self .current == \u0026#39;name\u0026#39; :\rself .name = content\relif self .current == \u0026#39;age\u0026#39; :\rself .age = content\relif self .current == \u0026#39;weight\u0026#39; :\rself .weight = content\relif self .current == \u0026#39;height\u0026#39; :\rself .height = content\rhandler = GroupHandler()\rparser = xml.sax.make_parser()\rparser.setContentHandler(handler)\rparser.parse( \u0026#39;group.xml\u0026#39; ) \rThe first thing you will notice here is that we have three functions instead of one. When we start processing an element, the function startElement gets called. Then we go on to process the individual characters which are name, age, weight and height . At the end of the element parsing, we call the endElement function.\nIn this example, we first check if the element is a person or not. If this is the case we print the id just for information. We then go on with the characters method. It checks which tag belongs to which attribute and saves the values accordingly. At the end, we print out all the values. This is what the results look like:\n— Person —\rID: 1\rName: John Smith\rAge: 20\rWeight: 80\rHeight: 188\r— Person —\rID: 2\rName: Mike Davis\rAge: 45\rWeight: 82\rHeight: 185\r— Person —\r…\n\rXML WITH DOM\rNow, let’s look at the DOM option. Here we can not only read from XML files but also change values and attributes. In order to work with DOM, we again need to import the respective module.\nimport xml.dom.minidom\rWhen working with DOM, we need to create a so-called DOM-Tree and view all elements as collections or sequences.\ndomtree = xml.dom.minidom.parse( \u0026#39;group.xml\u0026#39; )\rgroup = domtree.documentElement \rWe parse the XML file by using the method parse . This returns a DOM-tree, which we save into a variable. Then we get the documentElement of our tree and in our case this is group . We also save this one into an object.\npersons = group.getElementsByTagName( \u0026#39;person\u0026#39; )\rfor person in persons:\rprint ( \u0026#39;--- Person ---\u0026#39; )\rif person.hasAttribute( \u0026#39;id\u0026#39; ):\rprint ( \u0026#39;ID: %s\u0026#39; % person.getAttribute( \u0026#39;id\u0026#39; ))\rname = person.getElementsByTagName( \u0026#39;name\u0026#39; )[ 0 ]\rage = person.getElementsByTagName( \u0026#39;age\u0026#39; )[ 0 ]\rweight = person.getElementsByTagName( \u0026#39;weight\u0026#39; )[ 0 ]\rheight = person.getElementsByTagName( \u0026#39;height\u0026#39; )[ 0 ] \rNow, we can get all the individual elements by using the getElementsByTagName function. For example, we save all our person tags into a variable by using this method and specifying the name of our desired tags. Our persons variable is now a sequence that we can iterate over.\nBy using the functions hasAttribute and getAttribute, we can also access the attributes of our tags. In this case, this is only the id . In order to get the tag values of the individual person, we again use the method getElementsByTagName .\nWhen we do all that and execute our script, we get the exact same result as with SAX .\r— Person —\rID: 1\rName: John Smith\rAge: 20\rWeight: 80\rHeight: 188\r— Person —\rID: 2\rName: Mike Davis\rAge: 45\rWeight: 82\rHeight: 185\r— Person —\r…\n\rMANIPULATING XML FILES\rSince we are now working with DOM , let’s manipulate our XML file and change some values.\npersons = group.getElementsByTagName( \u0026#39;person\u0026#39; )\rpersons[ 0 ].getElementsByTagName( \u0026#39;name\u0026#39; )[ 0 ].childNodes[ 0 ].nodeValue = \u0026#39;New Name\u0026#39;\rAs you can see, we are using the same function, to access our elements. Here we adress the name tag of the first person object. Then we need to access the childNodes and change their nodeValue . Notice that we only have one element name and also only one child node but we still need to address the index zero, for the first element.\nIn this example, we change the name of the first person to New Name . Now in order to apply these changes to the real file, we need to write into it.\ndomtree.writexml( open ( \u0026#39;group.xml\u0026#39; , \u0026#39;w\u0026#39; ))\rWe use the writexml method of our initial domtree object. As a parameter, we pass a file stream that writes into our XML file. After doing that, we can look at the changes.\n\u0026lt; person id= \u0026#39;1\u0026#39; \u0026gt;\r\u0026lt; name \u0026gt;New Name\u0026lt;/ name \u0026gt;\r\u0026lt; age \u0026gt;20\u0026lt;/ age \u0026gt;\r\u0026lt; weight \u0026gt;80\u0026lt;/ weight \u0026gt;\r\u0026lt; height \u0026gt;188\u0026lt;/ height \u0026gt;\r\u0026lt;/ person \u0026gt;\rWe can also change the attributes by using the function setAttribute .\npersons[ 0 ].setAttribute( ‘id’ , ‘10’ )\rHere we change the attribute id of the first person to 10 .\n\u0026lt; person id= \u0026#39;10\u0026#39; \u0026gt;\r\u0026lt; name \u0026gt;New Name\u0026lt;/ name \u0026gt;\r\u0026lt; age \u0026gt;20\u0026lt;/ age \u0026gt;\r\u0026lt; weight \u0026gt;80\u0026lt;/ weight \u0026gt;\r\u0026lt; height \u0026gt;188\u0026lt;/ height \u0026gt;\r\u0026lt;/ person \u0026gt;\r\rCREATING NEW ELEMENTS\rThe last thing that we are going to look at in this chapter is creating new XML elements by using DOM. In order to do that, we first need to define a new person element.\nnewperson = domtree.createElement( \u0026#39;person\u0026#39; )\rnewperson.setAttribute( \u0026#39;id\u0026#39; , \u0026#39;6\u0026#39; )\rSo we use the domtree object and the respective method, to create a new XML element. Then we set the id attribute to the next number.\nAfter that, we create all the elements that we need for the person and assign values to them.\nname = domtree.createElement( \u0026#39;name\u0026#39; )\rname.appendChild(domtree.createTextNode( \u0026#39;Paul Smith\u0026#39; ))\rage = domtree.createElement( \u0026#39;age\u0026#39; )\rage.appendChild(domtree.createTextNode( \u0026#39;45\u0026#39; ))\rweight = domtree.createElement( \u0026#39;weight\u0026#39; )\rweight.appendChild(domtree.createTextNode( \u0026#39;78\u0026#39; ))\rheight = domtree.createElement( \u0026#39;height\u0026#39; )\rheight.appendChild(domtree.createTextNode( \u0026#39;178\u0026#39; )) \rFirst, we create a new element for each attribute of the person. Then we use the method appendChild to put something in between the tags of our element. In this case we create a new TextNode , which is basically just text.\nLast but not least, we again need to use the method appendChild in order to define the hierarchical structure. The attribute elements are the childs of the person element and this itself is the child of the group element.\nnewperson.appendChild(name)\rnewperson.appendChild(age)\rnewperson.appendChild(weight)\rnewperson.appendChild(height)\rgroup.appendChild(newperson)\rdomtree.writexml( open ( \u0026#39;group.xml\u0026#39; , \u0026#39;w\u0026#39; ))\rWhen we write these changes into our file, we can see the following results:\n\u0026lt; person id= \u0026#39;6\u0026#39; \u0026gt;\r\u0026lt; name \u0026gt;Paul Smith\u0026lt;/ name \u0026gt;\r\u0026lt; age \u0026gt;45\u0026lt;/ age \u0026gt;\r\u0026lt; weight \u0026gt;78\u0026lt;/ weight \u0026gt;\r\u0026lt; height \u0026gt;178\u0026lt;/ heigh\r\r\r",
    "ref": "/blog/python-xml-processing/"
  },{
    "title": "Python - Database Programming",
    "date": "",
    "description": "Introduction to Python Database Programming",
    "body": "\r\r\rDatabase Programming\r\rCONNECTING TO SQLITE\rEXECUTING STATEMENTS\rCREATING TABLES\rINSERTING VALUES\rSELECTING VALUES\rCLASSES AND TABLES\rFROM TABLE TO OBJECT\rFROM OBJECT TO TABLE\r\r\r\rDatabase Programming\rDatabases are one of the most popular ways to store and manage data in computer science. Because of that, in this chapter we are going to take a look at database programming with Python.\rNotice that for most databases we use the query language SQL , which stands for Structured Query Language . We use this language in order to manage the database, the tables and the rows and columns. This chapter is not about database structure itself, nor is it about SQL. Maybe I will write a specific SQL book in the future but here we are only going to focus on the implementation in Python. We are not going to explain the SQL syntax in too much detail.\nCONNECTING TO SQLITE\rThe database that comes pre-installed with Python is called SQLite . It is also the one which we are going to use. Of course, there are also other libraries for MySQL, MongoDB etc.\rIn order to use SQLite in Python, we need to import the respective module – sqlite3 .\nimport sqlite3\rNow, to create a new database file on our disk, we need to use the connect method.\nconn = sqlite3.connect( \u0026#39;mydata.db\u0026#39; )\rThis right here creates the new file mydata.db and connects to this database. It returns a connection object which we save in the variable conn .\n\rEXECUTING STATEMENTS\rSo, we have established a connection to the database. But in order to execute SQL statements, we will need to create a so-called cursor .\nc = conn.cursor()\rWe get this cursor by using the method cursor of our connection object that returns it. Now we can go ahead and execute all kinds of statements.\n\rCREATING TABLES\rFor example, we can create our first table like this:\nc.execute( \u0026#39;\u0026#39;\u0026#39;CREATE TABLE persons (\rfirst_name TEXT,\rlast_name TEXT,\rage INTEGER\r)\u0026#39;\u0026#39;\u0026#39; )\rHere we use the execute function and write our query. What we are passing here is SQL code. As I already said, understanding SQL is not the main objective here. We are focusing on the Python part. Nevertheless, it’s quite obvious what’s happening here. We are creating a new table with the name persons and each person will have the three attributes first_name, last_name and age .\nNow our statement is written but in order to really execute it, we ne need to commit to our connection.\nconn.commit()\rWhen we do this, our statement gets executed and our table created. Notice that this works only once, since after that the table already exists and can’t be created again.\rAt the end, don’t forget to close the connection, when you are done with everything.\nconn.close()\r\rINSERTING VALUES\rNow let’s fill up our table with some values. For this, we just use an ordinary INSERT statement.\nc.execute( \u0026#39;\u0026#39;\u0026#39;INSERT INTO persons VALUES\r(\u0026#39;John\u0026#39;, \u0026#39;Smith\u0026#39;, 25),\r(\u0026#39;Anna\u0026#39;, \u0026#39;Smith\u0026#39;, 30),\r(\u0026#39;Mike\u0026#39;, \u0026#39;Johnson\u0026#39;, 40)\u0026#39;\u0026#39;\u0026#39; )\rconn.commit()\rconn.close()\rSo basically, we are just adding three entries to our table. When you run this code, you will see that everything went fine. But to be on the safe side, we will try to now extract the values from the database into our program.\n\rSELECTING VALUES\rIn order to get values from the database, we need to first execute a SELECT statement. After that, we also need to fetch the results.\nc.execute( \u0026#39;\u0026#39;\u0026#39;SELECT * FROM persons\rWHERE last_name = \u0026#39;Smith\u0026#39;\u0026#39;\u0026#39;\u0026#39; )\rprint (c.fetchall())\rconn.commit()\rconn.close()\rAs you can see, our SELECT statement that gets all the entries where the last_name has the value Smith . We then need to use the method fetchall of the cursor, in order to get our results. It returns a list of tuples, where every tuple is one entry. Alternatively, we could use the method fetchone to only get the first entry or fetchmany to get a specific amount of entries. In our case however, the result looks like this:\r[(‘John’, ‘Smith’, 25), (‘Anna’, ‘Smith’, 30)]\n\rCLASSES AND TABLES\rNow in order to make the communication more efficient and easier, we are going to create a Person class that has the columns as attributes.\nclass Person():\rdef __init__ ( self , first= None ,last= None , age= None ):\rself .first = first\rself .last = last\rself .age = age\rdef clone_person( self , result):\rself .first = result[ 0 ]\rself .last = result[ 1 ]\rself .age = result[ 2 ]\rHere we have a constructor with default parameters. In case we don’t specify any values, they get assigned the value None . Also, we have a function clone_person that gets passed a sequence and assigns the values of it to the object. In our case, this sequence will be the tuple from the fetching results.\n\rFROM TABLE TO OBJECT\rSo let’s create a new Person object by getting its data from our database.\nc.execute( \u0026#39;\u0026#39;\u0026#39;SELECT * FROM persons\rWHERE last_name = \u0026#39;Smith\u0026#39;\u0026#39;\u0026#39;\u0026#39; )\rperson1 = Person()\rperson1.clone_person(c.fetchone())\rprint (person1.first)\rprint (person1.last)\rprint (person1.age)\rHere we fetch the first entry of our query results, by using the fetchone function. The result is the following:\rJohn\rSmith\r25\n\rFROM OBJECT TO TABLE\rWe can also do that the other way around. Let’s create a person objects, assign values to the attributes and then insert this object into our database.\nperson2 = Person( \u0026#39;Bob\u0026#39; , \u0026#39;Davis\u0026#39; , 23 )\rc.execute( \u0026#39;\u0026#39;\u0026#39;INSERT INTO persons VALUES\r(\u0026#39;{}\u0026#39;, \u0026#39;{}\u0026#39;, \u0026#39;{}\u0026#39;)\u0026#39;\u0026#39;\u0026#39;\r.format(person2.first,\rperson2.last,\rperson2.age))\rconn.commit()\rconn.close()\rHere we used the basic format function in order to put our values into the statement. When we execute it, our object gets inserted into the database. We can check this by printing all objects of the table persons .\nc.execute( \u0026#39;SELECT * FROM persons\u0026#39; )\rprint (c.fetchall())\rIn the results, we find our new object:\r[(\u0026#39;John\u0026#39;, \u0026#39;Smith\u0026#39;, 25), (\u0026#39;Anna\u0026#39;, \u0026#39;Smith\u0026#39;, 30), (\u0026#39;Mike\u0026#39;, \u0026#39;Johnson\u0026#39;, 40), (\u0026#39;Bob\u0026#39;, \u0026#39;Davis\u0026#39;, 23) ]\rPREPARED STATEMENTS\rThere is a much more secure and elegant way to put the values of our attributes into the SQL statements. We can use prepared statements .\nperson = Person( \u0026#39;Julia\u0026#39; , \u0026#39;Johnson\u0026#39; , 28 )\rc.execute( \u0026#39;INSERT INTO persons VALUES (?, ?, ?)\u0026#39; ,\r(person.first, person.last, person.age))\rconn.commit()\rconn.close()\rWe replace the values with question marks and pass the values as a tuple in the function. This makes our statements cleaner and also less prone to SQL injections.\n\r\r\r",
    "ref": "/blog/python-database-programming/"
  },{
    "title": "Python - Networking",
    "date": "",
    "description": "Introduction to Python Networking",
    "body": "\r\r\rNETWORK PROGRAMMING\r\rSOCKETS\rCREATING SOCKETS\rSERVER SOCKET METHODS\rCLIENT-SERVER ARCHITECTURE\rSERVER SOCKET METHODS\rCLIENT SOCKET METHODS\rOTHER SOCKET METHODS\rCREATING A SERVER\rCREATING A CLIENT\rCONNECTING SERVER AND CLIENT\rPORT SCANNER\rTHREADED PORT SCANNER\r\r\r\rNETWORK PROGRAMMING\rNow we get into one of the most interesting intermediate topics – network programming . It is about communicating with other applications and devices via some network. That can be the internet or just the local area network.\nSOCKETS\rWHAT ARE SOCKETS?\nWhenever we talk about networking in programming, we also have to talk about sockets . They are the endpoints of the communication channels or basically, the endpoints that talk to each other. The communication may happen in the same process or even across different continents over the internet.\rWhat’s important is that in Python we have different access levels for the network services. At the lower layers, we can access the simple sockets that allow us to use the connection-oriented and connectionless protocols like TCP or UDP, whereas other Python modules like FTP or HTTP are working on a higher layer – the application layer .\n\rCREATING SOCKETS\rIn order to work with sockets in Python, we need to import the module socket .\nimport socket\rNow, before we start defining and initializing our socket, we need to know a couple of things in advance:\r· Are we using an internet socket or a UNIX socket?\r· Which protocol are we going to use?\r· Which IP-address are we using?\r· Which port number are we using?\nThe first question can be answered quite simply. Since we want to communicate over a network instead of the operating system, we will stick with the internet socket .\nThe next question is a bit trickier. We choose between the protocols TCP ( Transmission Control Protocol) and UDP ( User Datagram Protocol). TCP is connection-oriented and more trustworthy than UDP. The chances of losing data are minimal in comparison to UDP. On the other hand, UDP is much faster than TCP. So the choice depends on the task we want to fulfil. For our examples, we will stick with TCP since we don’t care too much about speed for now.\nThe IP-address should be the address of the host our application will run on. For now, we will use 127.0.0.1 which is the localhost address. This applies to every machine. But notice that this only works when you are running your scripts locally.\nFor our port we can basically choose any number we want. But be careful with low numbers, since all numbers up to 1024 are standardized and all numbers from 1024 to 49151 are reserved . If you choose one of these numbers, you might have some conflicts with other applications or your operating system.\nimport socket\rs = socket.socket(socket.AF_INET,socket.SOCK_STREAM)\rHere we created our first socket, by initializing an instance of the class socket . Notice that we passed two parameters here. The first one AF_INET states that we want an internet socket rather than a UNIX socket . The second one SOCK_STREAM is for the protocol that we choose. In this case it stands\rfor TCP . If we wanted UDP , we would have to choose SOCK_DGRAM.\nA server opens up a session with every client that connects to it. This way, servers are able to serve multiple clients at once and individually.\n\rSERVER SOCKET METHODS\rThere are three methods of the socket class that are of high importance for the servers.\rSo we have a socket that uses the IP protocol (internet) and the TCP protocol. Now, before we get into the actual setup of the socket, we need to talk a little bit about clients and servers.\n\rCLIENT-SERVER ARCHITECTURE\rIn a nutshell, the server is basically the one who provides information and serves data, whereas the clients are the ones who request and receive the data from the server.A server opens up a session with every client that connects to it. This way, servers are able to serve multiple clients at once and individually.\n\rSERVER SOCKET METHODS\r\r\rSERVER SOCKET METHODS\r\r\r\r\rMETHOD\rDESCRIPTION\r\rbind()\rBinds the address that consists of hostname and port to the socket\r\rlisten()\rWaits for a message or a signal\r\raccept()\rAccepts the connection with a client\r\r\r\r\rCLIENT SOCKET METHODS\rFor the client, there is only one specific and very important method, namely connect . With this method the client attempts to connect to a server which then has to accept this with the respective method.\rThere are three methods of the socket class that are of high importance for the servers.\n\rOTHER SOCKET METHODS\r\r\rOTHER SOCKET METHODS\r\r\r\r\rMETHOD\rDESCRIPTION\r\rrecv()\rReceives a TCP message\r\rsend()\rSends a TCP message\r\rrecvfrom()\rReceives a UDP message\r\rsendto()\rSends a UDP message\r\rclose()\rCloses a socket\r\rgethostname()\rReturns hostname of a socket\r\r\r\r\rCREATING A SERVER\rNow that we understand the client-server architecture, we are going to implement our server. We decided that we want to use TCP and an internet socket. For the address we will use the localhost address 127.0.0.1 and as a port, we will choose 9999 .\ns = socket.socket(socket.AF_INET,\rsocket.SOCK_STREAM)\rs.bind(( \u0026#39;127.0.0.1\u0026#39; , 9999 ))\rs.listen()\rprint ( \u0026#39;Listening...\u0026#39; )\rHere we initialize our socket like we did in the beginning of this chapter. We then use the method bind , in order to assign the IP-address and the port we chose. Notice that we are passing a tuple as a parameter here. Last but not least, we put our socket to listening mode by using the method listen .After that, we just have to create a loop that accepts the client requests that will eventually come in.server.py\nimport socket\rs = socket.socket(socket.AF_INET,\rsocket.SOCK_STREAM)\rs.bind(( \u0026#39;127.0.0.1\u0026#39; , 9999 ))\rs.listen()\rprint ( \u0026#39;Listening...\u0026#39; )\rwhile True :\rclient, address = s.accept()\rprint ( \u0026#39;Connected to {}\u0026#39; .format(address))\rmessage = \u0026#39;Hello Client!\u0026#39;\rclient.send(message.encode( \u0026#39;ascii\u0026#39; ))\rclient.close()\rThe method accept waits for a connection attempt to come and accepts it. It then returns a client for responses and the address of the client that is connected. We can then use this client object in order to send the message. But it’s important that we encode the message first, because otherwise we can’t send it properly. At the end, we close the client because we don’t need it anymore.\rAlso, there are some other socket methods that are quite important in general.\n\rCREATING A CLIENT\rNow our server is done and we just need some clients that connect to it. Our clients shall request a resource from the server. In this case, this is the message “Hello Client!” .\rFor our client we also need a socket but this time it will not use the function bind but the function connect . So let’s start writing our code into a new file.\nimport socket\rs = socket.socket(socket.AF_INET,\rsocket.SOCK_STREAM)\rs.connect(( \u0026#39;127.0.0.1\u0026#39; , 9999 ))\rWe just create an ordinary internet socket that uses TCP and then connect it to the localhost IP-address at the port 9999.\rTo now get the message from the server and decode it, we will use the recv function.\rclient.py\nimport socket\rs = socket.socket(socket.AF_INET,socket.SOCK_STREAM)\rs.connect(( \u0026#39;127.0.0.1\u0026#39; , 9999 ))\rmessage = s.recv( 1024 )\rs.close()\rprint (message.decode( \u0026#39;ascii\u0026#39; ))\rAfter we connect to the server, we try to receive up to 1024 bytes from it. We then save the message into our variable and then we decode and print it.\n\rCONNECTING SERVER AND CLIENT\rNow in order to connect these two entities, we first need to run our server. If there is no server listening on the respective port, our client can’t connect to anything. So we run our server.py script and start listening.\rAfter that, we can run our client.py script many times and they will all connect to the server. The results will look like this:\nServer\rListening…\rConnected to (‘127.0.0.1’, 4935)\rConnected to (‘127.0.0.1’, 4942)\rConnected to (‘127.0.0.1’, 4943)\rConnected to (‘127.0.0.1’, 4944)\rConnected to (‘127.0.0.1’, 4945)\nClient\rHello Client!\rOne thing you might optimize on that script if you want is the exception handling. If there is no server listening and our client tries to connect, we get a ConnectionRefusedError and our script crashes. Now you can fix this with the knowledge from the first book.\n\rPORT SCANNER\rNow we have learned a lot about multithreading, locking, queues and sockets. With all that knowledge, we can create a highly efficient and well working port scanner .\rWhat a port scanner basically does is: It tries to connect to certain ports at a host or a whole network, in order to find loopholes for future attacks. Open ports mean a security breach. And with our skills, we can already code our own penetration testing tool.\nimport socket\rtarget = \u0026#39;10.0.0.5\u0026#39;\rdef portscan(port):\rtry :\rs = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\rconn = s.connect((target, port))\rreturn True\rexcept :\rreturn False\rfor x in range ( 1 , 501 ):\rif (portscan(x)):\rprint ( \u0026#39;Port {} is open!\u0026#39; .format(x))\relse :\rprint ( \u0026#39;Port {} is closed!\u0026#39; .format(x))\rSo this scanner is quite simple. We define a target address. In this case, this is 10.0.0.5 . Our function portscan simply tries to connect to a certain port at that host. If it succeeds, the function returns True . If we get an error or an exception, it returns False .\rThis is as simple as a port scan can get. We then use a for loop to scan the first 500 ports and we always print if the port is open or closed.\nJust choose a target address and run this script. You will see that it works.\rPort 21 is closed!\rPort 22 is open!\rPort 23 is closed!\rPort 24 is closed!\rPort 25 is open!\nBut you will also notice that it is extremely slow. That’s because we serially scan one port after the other. And I think we have already learned how to handle that.\n\rTHREADED PORT SCANNER\rIn order to speed up the scanning process, we are going to use multithreading . And to make sure that every port gets scanned and also that no port is scanned twice, we will use queues.\nimport socket\rfrom queue import Queue\rimport threading\rtarget = \u0026#39;10.0.0.5\u0026#39;\rq = Queue()\rfor x in range ( 1 , 501 ):\rq.put(x)\rdef portscan(port):\rtry :\rs = socket.socket(socket.AF_INET,socket.SOCK_STREAM)\rconn = s.connect((target, port))\rreturn True\rexcept :\rreturn False\rdef worker():\rwhile True :\rport = q.get()\rif portscan(port):\rprint ( \u0026#39;Port {} is open!\u0026#39;.format(port))\rSo we start by creating a queue and filling it up with all numbers from 1 to 500. We then have two functions. The portscan function does the scanning itself and the worker function gets all the ports from the queue in order to pass them to the portscan function and prints the result. In order to not get confused with the output, we only print when a port is open because we don’t care when a port is closed.\nNow we just have to decide how many threads we want to start and then we can go for it.\nfor x in range ( 30 ):\rt = threading.Thread( target =worker)\rt.start()\rIn this example, we start 30 threads at the same time. If you run this, you will see that it increases the scanning speed a lot. Within a few seconds, all the 500 ports are scanned. So if you want, you can increase the number to 5000.\nThe results for my virtual server are the following:\rPort 25 is open!\rPort 22 is open!\rPort 80 is open!\rPort 110 is open!\rPort 119 is open!\rPort 143 is open!\rPort 443 is open!\rPort 465 is open!\nAs you can see, there are a lot of vulnerabilities here. You now just have to google which ports are interesting and depending on your side you may either prepare for an attack or fix the security breaches. For example port 22 is SSH and quite dangerous.\n\r\r",
    "ref": "/blog/python-networking/"
  },{
    "title": "Python - Queues",
    "date": "",
    "description": "Introduction to Python Queues",
    "body": "\r\r\rQueues\r\rQUEUING RESOURCES\rLIFO QUEUES\rPRIORITIZING QUEUES\r\r\r\rQueues\rIn Python, queues are structures that take in data in a certain order to then output it in a certain order. The default queue type is the so-called FIFO queue . This stands for first in first out and the name describes exactly what it does. The elements that enter the queue first are also the elements that will leave the queue first.\nimport queue\rq = queue.Queue()\rfor x in range ( 5 ):\rq.put(x)\rfor x in range ( 5 ):\rprint (q.get(x))\rIn order to work with queues in Python, we need to import the module queue . We can then create an instance of the class Queue by using the constructor.\nAs you can see, we apply two functions here – put and get . The put function adds an element to the queue that can then be extracted by the get function.\nHere, we keep numbers one to five into our queue. Then, we just get the elements and print them. The order stays the same, since the default queue is FIFO .\nQUEUING RESOURCES\rLet’s say we have a list of numbers that need to be processed. We decide to use multiple threads, in order to speed up the process. But there might be a problem. The threads don’t know which number has already been processed and they might do the same work twice, which would be unnecessary. Also, solving the problem with a counter variable won’t always work, because too many threads access the same variable and numbers might get skipped.\rIn this case we can just use queues to solve our problems. We fill up our queue with the numbers and every thread just uses the get function, to get the next number and process it.\rLet’s assume we have the following worker function:\nimport threading\rimport queue\rimport math\rq = queue.Queue()\rthreads = []\rdef worker():\rwhile True :\ritem = q.get()\rif item is None :\rbreak\rprint (math.factorial(item))\rq.task_done()\rWe start out with an empty queue and an empty list for threads. Our function has an endless loop that gets numbers from the list and calculates the factorial of them. For this factorial function, we need to import the module math . But you can ignore this part, since it is only used because the computation requires a lot of resources and takes time. At the end, we use the function task_done of the queue, in order to signal that the element was processed.\nfor x in range ( 5 ):\rt = threading.Thread( target =worker)\rt.start()\rthreads.append(t)\rzahle = [ 1340000 , 13 , 3, 300 , 98 , 88 , 11 , 23 ]\rfor item in zahle:\rq.put(item)\rq.join()\rfor i in range ( 5 ):\rq.put( None )\rWe then use a for loop to create and start five threads that we also add to our list. After that, we create a list of numbers, which we then all put into the queue.\nThe method join of the queue waits for all elements to be extracted and processed. Basically, it is going to wait for all the task_done functions. After that, we put None elements into the queue, so that our loops break.\nNotice that our threads can’t process the same element twice or even skip one because they can only get them by using the get function.\rIf we would use a counter for this task, two threads might increase it at the same time and then skip an element. Or they could just access the same element simultaneously. Queues are irreplaceable for tasks like this. We will see a quite powerful application of queues in the chapter about networking .\n\rLIFO QUEUES\rAlternative to the FIFO queues is LIFO queues . That stands for last in first out . You can imagine this queue like some sort of stack. The element you put last on top of the stack is the first that you can get from it.\nimport queue\rq = queue.LifoQueue()\rnumbers = [ 1 , 2 , 3 , 4 , 5 ]\rfor x in numbers:\rq.put(x)\rwhile not q.empty():\rprint (q.get())\rBy using the LifoQueue class from the queue module, we can create an instance of this type. When we now put in the numbers one to five in ascending order, we will get them back in descending order.\rThe result would be:\r5 4 3 2 1\n\rPRIORITIZING QUEUES\rWhat you can also do in Python, is creating prioritized queues . In these, every element gets assigned a level of priority that determines when they will leave the queue.\nimport queue\rq = queue.PriorityQueue()\rq.put(( 8 , \u0026#39;Some string\u0026#39; ))\rq.put(( 1 , 2023 ))\rq.put(( 90 , True ))\rq.put(( 2 , 10.23 ))\rwhile not q.empty():\rprint (q.get())\rHere, we create a new instance of the class PriorityQueue . When we put a new element into this queue, we need to pass a tuple as a parameter. The first element of the tuple is the level of importance (the lower the number, the higher the priority) and the second element is the actual object or value that we want to put into the queue.\nWhen we execute the print statement of the loop, we get the following results:\n(1, 2023)\r(2, 10.23)\r(8, ‘Some string’)\r(90, True)\nAs you can see, the elements got sorted by their priority number. If you only want to access the actual value, you need to address the index one because it is the second value of the tuple.\rwhile not q.empty():\rprint (q.get()[ 1 ])\n\r\r",
    "ref": "/blog/python-queues/"
  },{
    "title": "Python - Multithreading",
    "date": "",
    "description": "Introduction to Python Multithreading",
    "body": "\r\r\rMultithreading\r\rHow a thread works\r\rhow to start thread\rStart Vs Run\rWaiting for threads\rThread classes\rSynchronizing Threads\r\r\rSemaphores\r\rDaemon Threads\r\r\r\r\rMultithreading\rThreads are lightweight processes that perform certain actions in a program and they are part of a process themselves. These threads can work in parallel with each other in the same way as two individual applications can.\nSince threads in the same process share the memory space for the variables and the data, they can exchange information and communicate efficiently. Also, threads need fewer resources than processes. That’s why they’re often called lightweight processes.\nHow a thread works\rA thread has a beginning or a start, a working sequence and an end. But it can also be stopped or put on hold at any time. The latter is also called sleep .\rThere are two types of threads: Kernel Threads and User Threads . Kernel threads are part of the operating system, whereas user threads are managed by the programmer. That’s why we will focus on user threads in this book.\nIn Python, a thread is a class that we can create instances of. Each of these instances then represents an individual thread which we can start, pause or stop. They are all independent from each other and they can perform different operations at the same time.\nFor example, in a video game, one thread could be rendering all the graphics, while another thread processes the keyboard and mouse inputs. It would be unthinkable to serially perform these tasks one after the other.\nhow to start thread\rIn order to work with threads in Python, we will need to import the respective library threading .\nimport threading\rThen, we need to define our target function. This will be the function that contains the code that our thread shall be executing. Let’s just keep it simple for the beginning and write a hello world function.\nimport threading\rdef hello():\rprint ( \u0026#39;Hello World!\u0026#39; )\rt1 = threading.Thread( target =hello)\rt1.start()\rAfter we have defined the function, we create our first thread. For this, we use the class Thread of the imported threading module. As a parameter, we specify the target to be the hello function. Notice that we don’t put parentheses after our function name here, since we are not calling it but just referring to it. By using the start method we put our thread to work and it executes our function.\n\rStart Vs Run\rIn this example, we used the function start to put our thread to work. Another alternative would be the function run . The difference between these two functions gets important, when we are dealing with more than just one thread.\rWhen we use the run function to execute our threads, they run serially one after the other. They wait for each other to finish. The start function puts all of them to work simultaneously.\rThe following example demonstrates this difference quite well.\nimport threading\rdef function1():\rfor x in range ( 1000 ):\rprint ( \u0026#39;ONE\u0026#39; )\rdef function2():\rfor x in range ( 1000 ):\rprint ( \u0026#39;TWO\u0026#39; )\rt1 = threading.Thread( target =function1)\rt2 = threading.Thread( target =function2)\rt1.start()\rt2.start()\rWhen you run this script, you will notice that the output alternates between ONEs and TWOs . Now if you use the run function instead of the start function, you will see 1000 times ONE followed by 1000 times TWO . This shows you that the threads are run serially and not in parallel.\nOne more thing that you should know is that the application itself is also the main thread, which continues to run in the background. So while your threads are running, the code of the script will be executed unless you wait for the threads to finish.\n\rWaiting for threads\rimport threading\rdef function():\rfor x in range ( 500000 ):\rprint ( \u0026#39;HELLO WORLD!\u0026#39; )\rt1 = threading.Thread( target =function)\rt1.start()\rprint ( \u0026#39;THIS IS THE END!\u0026#39; )\rIf you execute this code, you will start printing the text “HELLO WORLD!” 500,000 times. But what you will notice is that the last print statement gets executed immediately after our thread starts and not after it ends.\nt1 = threading.Thread( target =function)\rt1.start()\rt1.join()\rprint ( \u0026#39;THIS IS THE END!\u0026#39; )\rBy using the join function here, we wait for the thread to finish before we move on with the last print statement. If we want to set a maximum time that we want to wait, we just pass the number of seconds as a parameter.\nt1 = threading.Thread( target =function)\rt1.start()\rt1.join( 5 )\rprint ( \u0026#39;THIS IS THE END!\u0026#39; )\rIn this case, we will wait for the thread to finish but only a maximum of five seconds. After this time has passed we will proceed with the code.\rNotice that we are only waiting for this particular thread. If we would have other threads running at the same time, we would have to call the join function on each of them in order to wait for all of them.\n\rThread classes\rAnother way to build our threads is to create a class that inherits the Thread class. We can then modify the run function and implement our functionality. The start function is also using the code from the run function so we don’t have to worry about that.\nimport threading\rclass MyThread(threading.Thread):\rdef __init__ ( self , message):\rthreading.Thread. __init__ ( self )\rself .message = message\rdef run( self ):\rfor x in range ( 100 ):\rprint ( self .message)\rmt1 = MyThread( \u0026#39;This is my thread message!\u0026#39; )\rmt1.start()\rIt is basically the same but it offers more modularity and structure, if you want to use attributes and additional functions.\n\rSynchronizing Threads\rSometimes you are going to have multiple threads running that all try to access the same resource. This may lead to inconsistencies and problems. In order to prevent such things there is a concept called locking . Basically, one thread is locking all of the other threads and they can only continue to work when the lock is removed.\nI came up with the following quite trivial example. It seems a bit abstract but you can still get the concept here.\nimport threading\rimport time\rx = 8192\rdef halve():\rglobal x\rwhile (x \u0026gt; 1 ):\rx /= 2\rprint (x)\rtime.sleep( 1 )\rprint ( \u0026#39;END!\u0026#39; )\rdef double():\rglobal x\rwhile (x \u0026lt; 16384 ):\rx *= 2\rprint (x)\rtime.sleep( 1 )\rprint ( \u0026#39;END!\u0026#39; )\rt1 = threading.Thread( target =halve)\rt2 = threading.Thread( target =double)\rt1.start()\rt2.start()\rHere we have two functions and the variable x that starts at the value 8192 . The first function halves the number as long as it is greater than one, whereas the second function doubles the number as long as it is less than 16384 .\nAlso, I’ve imported the module time in order to use the function sleep . This function puts the thread to sleep for a couple of seconds (in this case one second). So it pauses. We just do that, so that we can better track what’s happening.\rWhen we now start two threads with these target functions, we will see that the script won’t come to an end. The halve function will constantly decrease the number and the double function will constantly increase it.\nimport threading\rimport time\rx = 8192\rlock = threading.Lock()\rdef halve():\rglobal x, lock\rlock.acquire()\rwhile (x \u0026gt; 1 ):\rx /= 2\rprint (x)\rtime.sleep( 1 )\rprint ( \u0026#39;END!\u0026#39; )\rlock.release()\rdef double():\rglobal x, lock\rlock.acquire()\rwhile (x \u0026lt; 16384 ):\rx *= 2\rprint (x)\rtime.sleep( 1 )\rprint ( \u0026#39;END!\u0026#39; )\rlock.release()\rt1 = threading.Thread( target =halve)\rt2 = threading.Thread( target =double)\rt1.start()\rt2.start()\rSo here we added a couple of elements. First of all we defined a Lock object. It is part of the threading module and we need this object in order to manage the locking.\rNow, when we want to try to lock the resource, we use the function acquire . If the lock was already locked by someone else, we wait until it is released again before we continue with the code. However, if the lock is free, we lock it ourselves and release it at the end using the release function.\rHere, we start both functions with a locking attempt. The first function that gets executed will lock the other function and finish its loop. After that it will release the lock and the other function can do the same.\rSo the number will be halved until it reaches the number one and then it will be doubled until it reaches the number 16384 .\n\r\r\rSemaphores\rSometimes we don’t want to completely lock a resource but just limit it to a certain amount of threads or accesses. In this case, we can use so-called semaphores .\rTo demonstrate this concept, we will look at another very abstract example.\nimport threading\rimport time\rsemaphore = threading.BoundedSemaphore( value = 5 )\rdef access(thread_number):\rprint ( \u0026#39;{}: Trying access...\u0026#39;.format(thread_number))\rsemaphore.acquire()\rprint ( \u0026#39;{}: Access granted!\u0026#39;.format(thread_number))\rprint ( \u0026#39;{}: Waiting 5 seconds...\u0026#39;.format(thread_number))\rtime.sleep( 5 )\rsemaphore.release()\rprint ( \u0026#39;{}: Releasing!\u0026#39;.format(thread_number))\rfor thread_number in range ( 10 ):\rt = threading.Thread( target =access,args =(thread_number,))\rt.start()\rWe first use the BoundedSemaphore class to create our semaphore object. The parameter value determines how many parallel accesses we allow. In this case, we choose five.\rWith our access function, we try to access the semaphore. Here, this is also done with the acquire function. If there are less than five threads utilizing the semaphore, we can acquire it and continue with the code. But when it’s full, we need to wait until some other thread frees up one space.\rWhen we run this code, you will see that the first five threads will immediately run the code, whereas the remaining five threads will need to wait five seconds until the first threads release the semaphore.\rThis process makes a lot of sense when we have limited resources or limited computational power in a system and we want to limit the access to it.\nWith events we can manage our threads even better. We can pause a thread and wait for a certain event to happen, in order to continue it.\nimport threading\revent = threading.Event()\rdef function():\rprint ( \u0026#39;Waiting for event...\u0026#39; )\revent.wait()\rprint ( \u0026#39;Continuing!\u0026#39; )\rthread = threading.Thread( target =function)\rthread.start()\rx = input ( \u0026#39;Trigger event?\u0026#39; )\rif (x == \u0026#39;yes\u0026#39; ):\revent.set()\rTo define an event we use the Event class of the threading module. Now we define our function which waits for our event. This is done with the wait function. So we start the thread and it waits.\rThen we ask the user, if he wants to trigger the event. If the answer is yes, we trigger it by using the set function. Once the event is triggered, our function no longer waits and continues with the code.\nDaemon Threads\rSo-called daemon threads are a special kind of thread that runs in the background. This means that the program can be terminated even if this thread is still running. Daemon threads are typically used for background tasks like synchronizing, loading or cleaning up files that are not needed anymore. We define a thread as a daemon by setting the respective parameter in the constructor for Thread to True .\nimport threading\rimport time\rpath = \u0026#39;text.txt\u0026#39;\rtext = \u0026#39;\u0026#39;\rdef readFile():\rglobal path, text\rwhile True :\rwith open (path) as file:\rtext = file.read()\rtime.sleep( 3 )\rdef printloop():\rglobal text\rfor x in range ( 30 ):\rprint (text)\rtime.sleep( 1 )\rt1 = threading.Thread( target =readFile, daemon = True )\rt2 = threading.Thread( target =printloop)\rt1.start()\rt2.start()\rSo, here we have two functions. The first one constantly reads in the text from a file and saves it into the text variable. This is done in an interval of three seconds. The second one prints out the content of text every second but only 30 times.\nAs you can see, we start the readFile function in a daemon thread and the printloop function in an ordinary thread. So when we run this script and change the content of the text.txt file while it is running, we will see that it prints the actual content all the time. Of course, we first need to create that file manually.\nAfter it printed the content 30 times however, the whole script will stop, even though the daemon thread is still reading in the files. Since the ordinary threads are all finished, the program ends and the daemon thread just gets terminated With locking we can now let one function finish before the next function starts. Of course, in this example this is not very useful but we can do the same thing in much more complex situations.\n\r\r",
    "ref": "/blog/python-multithreading/"
  },{
    "title": "Python - Classes and Objects",
    "date": "",
    "description": "Introduction to Python Classes and Objects",
    "body": "\r\r\rClasses and Objects\r\rCreating Classes\r\rConstructor\rAdding Functions\rClass Variables\rDestructors\rCreating Objects\rHidden Attributes\r\rInheritence\r\r\r\r\rClasses and Objects\rPython is an object-oriented language which means that the code can be divided into individual units, namely objects . Each of these objects is an instance of a so-called class . You can think of the class as some sort of blueprint. For example, the blueprint of a car could be the class and an object would be the actual physical car. So a class has specific attributes and functions but the values vary from object to object.\nCreating Classes\rIn Python, we use the keyword class in order to define a new class. Whatever which is indented after the colon belongs to the class.\nclass Car:\rdef __init__ ( self , manufacturer, model, hp):\rself .manufacturer = manufacturer\rself .model = model\rself .hp = hp\rAfter the class keyword, we put the class name. In this example, this is Car .\nConstructor\rWhat we find first in this case, is a special function called init . This is the so-called constructor. Every time we create an instance or an object of our class, we use this constructor. As you can see, it accepts a couple of parameters. The first one is the parameter self and it is mandatory. Every function of the class needs to have at least this parameter.\rThe other parameters are just our custom attributes. In this case, we have chosen the manufacturer, the model and the horse power (hp).\rWhen we write self.attribute , we refer to the actual attribute of the respective object. We then assign the value of the parameters to it.\n\rAdding Functions\rWe can simply create and add functions to our class that perform certain actions. These functions can also access the attributes of the class.\nclass Car:\rdef __init__ ( self , manufacturer, model, hp):\rself .manufacturer = manufacturer\rself .model = model\rself .hp = hp\rdef print_info( self ):\rprint ( \u0026#39;Manufacturer: {}, Model: {}, HP; {}\u0026#39;.format( self .manufacturer, self.model,self.hp))\rHere we have the function print_info that prints out information about the attributes of the respective object. Notice that we also need the parameter self here.\n\rClass Variables\rIn the following code, you can see that we can use one and the same variable across all the objects of the class, when it is defined without referring to self .\nclass Car:\ramount_cars = 0\rdef __init__ ( self , manufacturer, model, hp):\rself .manufacturer = manufacturer\rself .model = model\rself .hp = hp\rCar.amount_cars += 1\rdef print_car_amount( self ):\rprint ( \u0026#39;Amount: {}\u0026#39;.format(Car.amount_cars)) def print_info( self ):\rprint ( \u0026#39;Manufacturer: {}, Model: {}, HP; {}\u0026#39;.format( self .manufacturer, self.model,self.hp)) \rThe variable amount_cars doesn’t belong to the individual object since it’s not addressed with self . It is a class variable and its value is the same for all objects or instances.\rWhenever we create a new car object, it increases by one. Then, every object can access and print the amount of existing cars.\n\rDestructors\rIn Python, we can also specify a method that gets called when our object gets destroyed or deleted and is no longer needed. This function is called destructor and it is the opposite of the constructor .\nclass Car:\ramount_cars = 0\rdef __init__ ( self , manufacturer, model, hp):\rself.manufacturer = manufacturer\rself.model = model\rself.hp = hp\rCar.amount_cars += 1\rdef __del__ ( self ):\rprint ( \u0026#39;Object gets deleted!\u0026#39; )\rCar.amount_cars -= 1 def print_car_amount( self ):\rprint ( \u0026#39;Amount: {}\u0026#39;.format(Car.amount_cars)) def print_info( self ):\rprint ( \u0026#39;Manufacturer: {}, Model: {}, HP; {}\u0026#39;.format( self .manufacturer, self.model,self.hp)) \rThe destructor function is called del . In this example, we print an informational message and decrease the amount of existing cars by one, when an object gets deleted.\n\rCreating Objects\rNow that we have implemented our class, we can start to create some objects of it.\nmyCar1 = Car( \u0026#39;Tesla1\u0026#39; , \u0026#39;Model X1\u0026#39; , 5251 )\rFirst, we specify the name of our object, like we do with ordinary variables. In this case, the object is called myCar1 . We then create an object of the Car class by writing the class name as a function. This calls the constructor, so we can pass our parameters. We can then use the functions of our car object.\nmyCar1.print_info()\r## Manufacturer: Tesla1, Model: Model X1, HP; 5251\rmyCar1.print_car_amount()\r## Amount: 1\rThe results look like this:\rManufacturer: Tesla, Model: Model X, HP; 525\rAmount: 1\rWhat you can also do is directly access the attributes of an object.\nprint (myCar1.manufacturer)\r## Tesla1\rprint (myCar1.model)\r## Model X1\rprint (myCar1.hp)\r## 5251\rNow we can create some more cars and see how the amount changes.\nmyCar1 = Car( \u0026#39;Tesla1\u0026#39; , \u0026#39;Model X1\u0026#39; , 525 )\r## Object gets deleted!\rmyCar2 = Car( \u0026#39;BMW1\u0026#39; , \u0026#39;X31\u0026#39; , 2001 )\rmyCar3 = Car( \u0026#39;VW1\u0026#39; , \u0026#39;Golf1\u0026#39; , 1001)\rmyCar4 = Car( \u0026#39;Porsche1\u0026#39; , \u0026#39;9111\u0026#39; , 5201 )\rdel myCar3\r## Object gets deleted!\rmyCar1.print_car_amount()\r## Amount: 3\rHere we first create four different car objects. We then delete one of them and finally we print out the car amount. The result is the following:\rObject gets deleted!\rAmount: 3\rNotice that all the objects get deleted automatically when our program ends. But we can manually delete them before that happens by using the del keyword.\n\rHidden Attributes\rIf we want to create hidden attributes that can only be accessed within the class, we can do this with underlines .\nclass MyClass:\rdef __init__ ( self ):\rself.__hidden = \u0026#39;Hello\u0026#39;\rprint ( self .__hidden) # Works\rm1 = MyClass()\r# print (m1.__hidden) # Doesn\u0026#39;t Work \r## Hello\rBy putting two underlines before the attribute name, we make it invisible from outside the class. The first print function works because it is inside of the class. But when we try to access this attribute from the object, we can’t.\n\r\rInheritence\rOne very important and powerful concept of object-oriented programming is inheritance . It allows us to use existing classes and to extend them with new attributes and functions.\rFor example, we could have the parent class which represents a Person and then we could have many child classes like Dancer, Policeman, Artist etc. All of these would be considered a person and they would have the same basic attributes. But they are special kinds of persons with more attributes and functions.\nclass Person:\rdef __init__ ( self , name, age):\rself .name = name\rself .age = age\rdef get_older( self , years):\rself .age += years\rclass Programmer(Person):\rdef __init__ ( self , name, age, language):\rsuper (Programmer, self ). __init__ (name, age)\rself .language = language\rdef print_language( self ):\rprint ( \u0026#39;Favorite Programming Language: {}\u0026#39;.format( self .language)) \r\r\r",
    "ref": "/blog/python-basics-2/"
  },{
    "title": "Python - Basics",
    "date": "",
    "description": "Introduction to Python.",
    "body": "\r\r\rVariables and Data Types\r\rNUMERICAL DATA TYPES\rSTRINGS\rBOOLEANS\rSEQUENCES\rCREATING VARIABLES\rUSING VARIABLES\rTYPECASTING\r\rPython loops and types\r\r1. For loop\r2. While loop\r3. Sequences - Lists\r4. Sequences - Lists - Operations\r5. Sequences - Lists - Functions\r6. Sequences - Lists - METHODS\r7. Sequences - Tupples\r\r\r\rVariables and Data Types\rVariables and Data types basically are just placeholders for values. In programming, that’s the same. The difference is that we have a lot of different data types, and variables cannot only store values of numbers but even of whole objects.\rIn this chapter we are going to take a look at variables in Python and the differences of the individual data types. Also, we will talk about type conversions.\nNUMERICAL DATA TYPES\rThe types you probably already know from mathematics are numerical data types. There are different kinds of numbers that can be used for mathematical operations.\n\r\rNUMERICAL DATA TYPES\r\r\r\r\r\rInteger\rint\rwhole number\r\rFloat\rfloat\rfloating point number\r\rComplex\rcomplex\rcomplex number\r\r\r\rAs you can see, it’s quite simple. An integer is just a regular whole number, which we can do basic calculations with. A float extends the integer and allows decimal places because it is a floating point number. And a complex number is what just a number that has a real and an imaginary component. If you don’t understand complex numbers mathematically, forget about them. You don’t need them for your programming right now.\n\rSTRINGS\rA string defines characters sequences. Our text that we printed in the last chapter was a string. Strings always need to be surrounded by quotation marks. Otherwise the interpreter will not realize that they are meant to be treated like text. The keyword for String in Python is str .\n\rBOOLEANS\rBoolean are the most simple data type in Python. They can only have one of two values, namely True or False . It’s a binary data type. We will use it a lot when we get to conditions and loops. The keyword here is bool .\n\rSEQUENCES\rSequences are a topic that we will cover in a later chapter. But since sequences are also data types we will at least mention that they exist.\n\r\rSEQUENCE TYPES\r\r\r\r\r\rList\rlist\rColection of values\r\rTuple\rtuple\rImutable list\r\rDictionary\rdict\rList of key nd value pairs\r\r\r\r\rCREATING VARIABLES\rCreating variables in Python is very simple. We just choose a name and assign a value.\nmyNumber = 10\rmyText = \u0026#39;Hello\u0026#39; \rHere, we defined two variables. The first one is an integer and the second one a string. You can basically choose whatever name you want but there are some limitations. For example you are not allowed to use reserved keywords like int or dict . Also, the name is not allowed to start with a number or a special character other than the underline.\n\rUSING VARIABLES\rNow that we have defined our variables, we can start to use them. For example, we could print the values.\nprint (myNumber)\r## 10\rprint (myText)\r## Hello\rSince we are not using quotation marks, the text in the parentheses is treated like a variable name. Therefore, the interpreter prints out the values 10 and “Hello” .\n\rTYPECASTING\rSometimes, we will get a value in a data type that we can’t work with properly. For example we might get a string as an input but that string contains a number as its value. Here “10” is not same to 10 . We can’t do calculations with a string, even if the text represents a number. For that reason we need to typecast.\nvalue = \u0026#39;10\u0026#39;\rnumber = int (value)\rTypecasting is done by using the specific data type function. In this case we are converting a string to an integer by using the int keyword. You can also reverse this by using the str keyword. This is a very important thing and we will need it quite often.\n\r\rPython loops and types\r1. For loop\rnumbers = [10,20,30,40]\rfor num in numbers:\rprint(num)\r\r## 10\r## 20\r## 30\r## 40\rfor num in range(10,41,10):\rprint(num)\r## 10\r## 20\r## 30\r## 40\r\r2. While loop\rnumber = 0\rwhile number \u0026lt; 10:\rnumber += 1\rif number == 5:\rbreak\rprint(number)\r## 1\r## 2\r## 3\r## 4\rnum = 0\rwhile num \u0026lt; 10:\rnum += 1\rif num == 5:\rcontinue\rprint(num)\r## 1\r## 2\r## 3\r## 4\r## 6\r## 7\r## 8\r## 9\r## 10\r\r3. Sequences - Lists\rnumbers = [10, 20, 30 ,40]\rnames = [\u0026#39;Arun\u0026#39;,\u0026#39;Varun\u0026#39;,\u0026#39;Karun\u0026#39;]\rmixed = [10,\u0026#39;Arun\u0026#39;, 28.3,True ]\rprint(numbers[3])\r## 40\rprint(names[0])\r## Arun\rprint(mixed[3])\r## True\rnumbers[3] = 3\rnames[2] = \u0026#39;Bob\u0026#39;\rprint(numbers[3])\r## 3\rprint(names[2])\r## Bob\r\r4. Sequences - Lists - Operations\r\r\rLIST OPERATIONS\r\r\r\r\rOPERATION\rRESULT\r\r[10, 20, 30] + [40, 50, 60]\r[10, 20, 30, 40, 50, 60]\r\r[10, “Bob”] * 3\r[10, “Bob”, 10, “Bob”, 10, “Bob”]\r\r\r\r\r5. Sequences - Lists - Functions\r\r\rLIST FUNCTIONS\r\r\r\r\rFUNCTION\rDESCRIPTION\r\rlen(list)\rReturns the length of a list\r\rmax(list)\rReturns the item with maximum value\r\rmin(list)\rReturns the item with minimum value\r\rlist(element)\rTypecasts element into list\r\r\r\r\r6. Sequences - Lists - METHODS\r\r\rLIST METHODS\r\r\r\r\rMETHOD\rDESCRIPTION\r\rlist.append(x)\rAppends element to the list\r\rlist.count(x)\rCounts how many times an element appears in the list\r\rlist.index(x)\rReturns the first index at which the given element occurs\r\rlist.pop()\rRemoves and returns last element\r\rlist.reverse()\rReverses the order of the elements\r\rlist.sort()\rSorts the elements of a list\r\r\r\r\r7. Sequences - Tupples\rtpl = (10,20,30)\rlen(tpl)\r## 3\rmax(tpl)\r## 30\rmin(tpl)\r## 10\r\r\r",
    "ref": "/blog/python-basics/"
  },{
    "title": "Kontakt",
    "date": "",
    "description": "",
    "body": "",
    "ref": "/contact/"
  }]
