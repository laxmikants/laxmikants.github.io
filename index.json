[{
    "title": "À propos de",
    "date": "",
    "description": "Hugo, le framework le plus rapide au monde pour la création de sites Web",
    "body": "Écrit dans Go, Hugo est un générateur de site statique open source disponible sous la [Apache License 2.0.] (Https://github.com/gohugoio/hugo/blob/master/LICENSE) Hugo prend en charge les types de fichiers de données TOML, YAML et JSON , Markdown et fichiers de contenu HTML et utilise des shortcodes pour ajouter du contenu riche. Les autres fonctionnalités notables sont les taxonomies, le mode multilingue, le traitement d\u0026rsquo;image, les formats de sortie personnalisés, la minification HTML / CSS / JS et la prise en charge des flux de travail Sass SCSS.\nHugo utilise une variété de projets open source, notamment:\n https://github.com/yuin/goldmark https://github.com/alecthomas/chroma https://github.com/muesli/smartcrop https://github.com/spf13/cobra https://github.com/spf13/viper  Hugo est idéal pour les blogs, les sites Web d\u0026rsquo;entreprise, les portefeuilles créatifs, les magazines en ligne, les applications d\u0026rsquo;une seule page ou même un site Web avec des milliers de pages.\nHugo est destiné aux personnes qui souhaitent coder manuellement leur propre site Web sans se soucier de la mise en place d\u0026rsquo;exécutions complexes, de dépendances et de bases de données.\nLes sites Web construits avec Hugo sont extrêmement rapides, sécurisés et peuvent être déployés n\u0026rsquo;importe où, y compris AWS, GitHub Pages, Heroku, Netlify et tout autre fournisseur d\u0026rsquo;hébergement.\nEn savoir plus et contribuer sur [GitHub] (https://github.com/gohugoio).\n",
    "ref": "/about/"
  },{
    "title": "Python - Multithreading",
    "date": "",
    "description": "Introduction to Python Multithreading",
    "body": "\r\rMULTITHREADING\rThreads are lightweight processes that perform certain actions in a program and they are part of a process themselves. These threads can work in parallel with each other in the same way as two individual applications can.\nSince threads in the same process share the memory space for the variables and the data, they can exchange information and communicate efficiently. Also, threads need fewer resources than processes. That’s why they’re often called lightweight processes.\nHOW A THREAD WORKS\rA thread has a beginning or a start, a working sequence and an end. But it can also be stopped or put on hold at any time. The latter is also called sleep .\rThere are two types of threads: Kernel Threads and User Threads . Kernel threads are part of the operating system, whereas user threads are managed by the programmer. That’s why we will focus on user threads in this book.\nIn Python, a thread is a class that we can create instances of. Each of these instances then represents an individual thread which we can start, pause or stop. They are all independent from each other and they can perform different operations at the same time.\nFor example, in a video game, one thread could be rendering all the graphics, while another thread processes the keyboard and mouse inputs. It would be unthinkable to serially perform these tasks one after the other.\n\rSTARTING THREADS\rIn order to work with threads in Python, we will need to import the respective library threading .\nimport threading\rThen, we need to define our target function. This will be the function that contains the code that our thread shall be executing. Let’s just keep it simple for the beginning and write a hello world function.\nimport threading\rdef hello():\rprint ( \u0026#39;Hello World!\u0026#39; )\rt1 = threading.Thread( target =hello)\rt1.start()\rAfter we have defined the function, we create our first thread. For this, we use the class Thread of the imported threading module. As a parameter, we specify the target to be the hello function. Notice that we don’t put parentheses after our function name here, since we are not calling it but just referring to it. By using the start method we put our thread to work and it executes our function.\n\rSTART VS RUN\rIn this example, we used the function start to put our thread to work. Another alternative would be the function run . The difference between these two functions gets important, when we are dealing with more than just one thread.\rWhen we use the run function to execute our threads, they run serially one after the other. They wait for each other to finish. The start function puts all of them to work simultaneously.\rThe following example demonstrates this difference quite well.\nimport threading\rdef function1():\rfor x in range ( 1000 ):\rprint ( \u0026#39;ONE\u0026#39; )\rdef function2():\rfor x in range ( 1000 ):\rprint ( \u0026#39;TWO\u0026#39; )\rt1 = threading.Thread( target =function1)\rt2 = threading.Thread( target =function2)\rt1.start()\rt2.start()\rWhen you run this script, you will notice that the output alternates between ONEs and TWOs . Now if you use the run function instead of the start function, you will see 1000 times ONE followed by 1000 times TWO . This shows you that the threads are run serially and not in parallel.\nOne more thing that you should know is that the application itself is also the main thread, which continues to run in the background. So while your threads are running, the code of the script will be executed unless you wait for the threads to finish.\n\rWAITING FOR THREADS\rimport threading\rdef function():\rfor x in range ( 500000 ):\rprint ( \u0026#39;HELLO WORLD!\u0026#39; )\rt1 = threading.Thread( target =function)\rt1.start()\rprint ( \u0026#39;THIS IS THE END!\u0026#39; )\rIf you execute this code, you will start printing the text “HELLO WORLD!” 500,000 times. But what you will notice is that the last print statement gets executed immediately after our thread starts and not after it ends.\nt1 = threading.Thread( target =function)\rt1.start()\rt1.join()\rprint ( \u0026#39;THIS IS THE END!\u0026#39; )\rBy using the join function here, we wait for the thread to finish before we move on with the last print statement. If we want to set a maximum time that we want to wait, we just pass the number of seconds as a parameter.\nt1 = threading.Thread( target =function)\rt1.start()\rt1.join( 5 )\rprint ( \u0026#39;THIS IS THE END!\u0026#39; )\rIn this case, we will wait for the thread to finish but only a maximum of five seconds. After this time has passed we will proceed with the code.\rNotice that we are only waiting for this particular thread. If we would have other threads running at the same time, we would have to call the join function on each of them in order to wait for all of them.\n\rTHREAD CLASSES\rAnother way to build our threads is to create a class that inherits the Thread class. We can then modify the run function and implement our functionality. The start function is also using the code from the run function so we don’t have to worry about that.\nimport threading\rclass MyThread(threading.Thread):\rdef __init__ ( self , message):\rthreading.Thread. __init__ ( self )\rself .message = message\rdef run( self ):\rfor x in range ( 100 ):\rprint ( self .message)\rmt1 = MyThread( \u0026#39;This is my thread message!\u0026#39; )\rmt1.start()\rIt is basically the same but it offers more modularity and structure, if you want to use attributes and additional functions.\n\rSYNCHRONIZING THREADS\rSometimes you are going to have multiple threads running that all try to access the same resource. This may lead to inconsistencies and problems. In order to prevent such things there is a concept called locking . Basically, one thread is locking all of the other threads and they can only continue to work when the lock is removed.\nI came up with the following quite trivial example. It seems a bit abstract but you can still get the concept here.\nimport threading\rimport time\rx = 8192\rdef halve():\rglobal x\rwhile (x \u0026gt; 1 ):\rx /= 2\rprint (x)\rtime.sleep( 1 )\rprint ( \u0026#39;END!\u0026#39; )\rdef double():\rglobal x\rwhile (x \u0026lt; 16384 ):\rx *= 2\rprint (x)\rtime.sleep( 1 )\rprint ( \u0026#39;END!\u0026#39; )\rt1 = threading.Thread( target =halve)\rt2 = threading.Thread( target =double)\rt1.start()\rt2.start()\rHere we have two functions and the variable x that starts at the value 8192 . The first function halves the number as long as it is greater than one, whereas the second function doubles the number as long as it is less than 16384 .\nAlso, I’ve imported the module time in order to use the function sleep . This function puts the thread to sleep for a couple of seconds (in this case one second). So it pauses. We just do that, so that we can better track what’s happening.\rWhen we now start two threads with these target functions, we will see that the script won’t come to an end. The halve function will constantly decrease the number and the double function will constantly increase it.\nimport threading\rimport time\rx = 8192\rlock = threading.Lock()\rdef halve():\rglobal x, lock\rlock.acquire()\rwhile (x \u0026gt; 1 ):\rx /= 2\rprint (x)\rtime.sleep( 1 )\rprint ( \u0026#39;END!\u0026#39; )\rlock.release()\rdef double():\rglobal x, lock\rlock.acquire()\rwhile (x \u0026lt; 16384 ):\rx *= 2\rprint (x)\rtime.sleep( 1 )\rprint ( \u0026#39;END!\u0026#39; )\rlock.release()\rt1 = threading.Thread( target =halve)\rt2 = threading.Thread( target =double)\rt1.start()\rt2.start()\rSo here we added a couple of elements. First of all we defined a Lock object. It is part of the threading module and we need this object in order to manage the locking.\rNow, when we want to try to lock the resource, we use the function acquire . If the lock was already locked by someone else, we wait until it is released again before we continue with the code. However, if the lock is free, we lock it ourselves and release it at the end using the release function.\rHere, we start both functions with a locking attempt. The first function that gets executed will lock the other function and finish its loop. After that it will release the lock and the other function can do the same.\rSo the number will be halved until it reaches the number one and then it will be doubled until it reaches the number 16384 .\n\rSEMAPHORES\rSometimes we don’t want to completely lock a resource but just limit it to a certain amount of threads or accesses. In this case, we can use so-called semaphores .\rTo demonstrate this concept, we will look at another very abstract example.\nimport threading\rimport time\rsemaphore = threading.BoundedSemaphore( value = 5 )\rdef access(thread_number):\rprint ( \u0026#39;{}: Trying access...\u0026#39;.format(thread_number))\rsemaphore.acquire()\rprint ( \u0026#39;{}: Access granted!\u0026#39;.format(thread_number))\rprint ( \u0026#39;{}: Waiting 5 seconds...\u0026#39;.format(thread_number))\rtime.sleep( 5 )\rsemaphore.release()\rprint ( \u0026#39;{}: Releasing!\u0026#39;.format(thread_number))\rfor thread_number in range ( 10 ):\rt = threading.Thread( target =access,args =(thread_number,))\rt.start()\rWe first use the BoundedSemaphore class to create our semaphore object. The parameter value determines how many parallel accesses we allow. In this case, we choose five.\rWith our access function, we try to access the semaphore. Here, this is also done with the acquire function. If there are less than five threads utilizing the semaphore, we can acquire it and continue with the code. But when it’s full, we need to wait until some other thread frees up one space.\rWhen we run this code, you will see that the first five threads will immediately run the code, whereas the remaining five threads will need to wait five seconds until the first threads release the semaphore.\rThis process makes a lot of sense when we have limited resources or limited computational power in a system and we want to limit the access to it.\nWith events we can manage our threads even better. We can pause a thread and wait for a certain event to happen, in order to continue it.\nimport threading\revent = threading.Event()\rdef function():\rprint ( \u0026#39;Waiting for event...\u0026#39; )\revent.wait()\rprint ( \u0026#39;Continuing!\u0026#39; )\rthread = threading.Thread( target =function)\rthread.start()\rx = input ( \u0026#39;Trigger event?\u0026#39; )\rif (x == \u0026#39;yes\u0026#39; ):\revent.set()\rTo define an event we use the Event class of the threading module. Now we define our function which waits for our event. This is done with the wait function. So we start the thread and it waits.\rThen we ask the user, if he wants to trigger the event. If the answer is yes, we trigger it by using the set function. Once the event is triggered, our function no longer waits and continues with the code.\n\r\rDAEMON THREADS\rSo-called daemon threads are a special kind of thread that runs in the background. This means that the program can be terminated even if this thread is still running. Daemon threads are typically used for background tasks like synchronizing, loading or cleaning up files that are not needed anymore. We define a thread as a daemon by setting the respective parameter in the constructor for Thread to True .\nimport threading\rimport time\rpath = \u0026#39;text.txt\u0026#39;\rtext = \u0026#39;\u0026#39;\rdef readFile():\rglobal path, text\rwhile True :\rwith open (path) as file:\rtext = file.read()\rtime.sleep( 3 )\rdef printloop():\rglobal text\rfor x in range ( 30 ):\rprint (text)\rtime.sleep( 1 )\rt1 = threading.Thread( target =readFile, daemon = True )\rt2 = threading.Thread( target =printloop)\rt1.start()\rt2.start()\rSo, here we have two functions. The first one constantly reads in the text from a file and saves it into the text variable. This is done in an interval of three seconds. The second one prints out the content of text every second but only 30 times.\nAs you can see, we start the readFile function in a daemon thread and the printloop function in an ordinary thread. So when we run this script and change the content of the text.txt file while it is running, we will see that it prints the actual content all the time. Of course, we first need to create that file manually.\nAfter it printed the content 30 times however, the whole script will stop, even though the daemon thread is still reading in the files. Since the ordinary threads are all finished, the program ends and the daemon thread just gets terminated With locking we can now let one function finish before the next function starts. Of course, in this example this is not very useful but we can do the same thing in much more complex situations.\n\r",
    "ref": "/blog/python-multithreading/"
  },{
    "title": "Python - Classes and Objects",
    "date": "",
    "description": "Introduction to Python Classes and Objects",
    "body": "\r\rCLASSES AND OBJECTS\rPython is an object-oriented language which means that the code can be divided into individual units, namely objects . Each of these objects is an instance of a so-called class . You can think of the class as some sort of blueprint. For example, the blueprint of a car could be the class and an object would be the actual physical car. So a class has specific attributes and functions but the values vary from object to object.\n\rCREATING CLASSES\rIn Python, we use the keyword class in order to define a new class. Whatever which is indented after the colon belongs to the class.\nclass Car:\rdef __init__ ( self , manufacturer, model, hp):\rself .manufacturer = manufacturer\rself .model = model\rself .hp = hp\rAfter the class keyword, we put the class name. In this example, this is Car .\n\rCONSTRUCTOR\rWhat we find first in this case, is a special function called init . This is the so-called constructor. Every time we create an instance or an object of our class, we use this constructor. As you can see, it accepts a couple of parameters. The first one is the parameter self and it is mandatory. Every function of the class needs to have at least this parameter.\rThe other parameters are just our custom attributes. In this case, we have chosen the manufacturer, the model and the horse power (hp).\rWhen we write self.attribute , we refer to the actual attribute of the respective object. We then assign the value of the parameters to it.\n\rADDING FUNCTIONS\rWe can simply create and add functions to our class that perform certain actions. These functions can also access the attributes of the class.\nclass Car:\rdef __init__ ( self , manufacturer, model, hp):\rself .manufacturer = manufacturer\rself .model = model\rself .hp = hp\rdef print_info( self ):\rprint ( \u0026#39;Manufacturer: {}, Model: {}, HP; {}\u0026#39;.format( self .manufacturer, self.model,self.hp))\rHere we have the function print_info that prints out information about the attributes of the respective object. Notice that we also need the parameter self here.\n\rCLASS VARIABLES\rIn the following code, you can see that we can use one and the same variable across all the objects of the class, when it is defined without referring to self .\nclass Car:\ramount_cars = 0\rdef __init__ ( self , manufacturer, model, hp):\rself .manufacturer = manufacturer\rself .model = model\rself .hp = hp\rCar.amount_cars += 1\rdef print_car_amount( self ):\rprint ( \u0026#39;Amount: {}\u0026#39;.format(Car.amount_cars)) def print_info( self ):\rprint ( \u0026#39;Manufacturer: {}, Model: {}, HP; {}\u0026#39;.format( self .manufacturer, self.model,self.hp)) \rThe variable amount_cars doesn’t belong to the individual object since it’s not addressed with self . It is a class variable and its value is the same for all objects or instances.\rWhenever we create a new car object, it increases by one. Then, every object can access and print the amount of existing cars.\n\rDESTRUCTORS\rIn Python, we can also specify a method that gets called when our object gets destroyed or deleted and is no longer needed. This function is called destructor and it is the opposite of the constructor .\nclass Car:\ramount_cars = 0\rdef __init__ ( self , manufacturer, model, hp):\rself.manufacturer = manufacturer\rself.model = model\rself.hp = hp\rCar.amount_cars += 1\rdef __del__ ( self ):\rprint ( \u0026#39;Object gets deleted!\u0026#39; )\rCar.amount_cars -= 1 def print_car_amount( self ):\rprint ( \u0026#39;Amount: {}\u0026#39;.format(Car.amount_cars)) def print_info( self ):\rprint ( \u0026#39;Manufacturer: {}, Model: {}, HP; {}\u0026#39;.format( self .manufacturer, self.model,self.hp)) \rThe destructor function is called del . In this example, we print an informational message and decrease the amount of existing cars by one, when an object gets deleted.\n\rCREATING OBJECTS\rNow that we have implemented our class, we can start to create some objects of it.\nmyCar1 = Car( \u0026#39;Tesla1\u0026#39; , \u0026#39;Model X1\u0026#39; , 5251 )\rFirst, we specify the name of our object, like we do with ordinary variables. In this case, the object is called myCar1 . We then create an object of the Car class by writing the class name as a function. This calls the constructor, so we can pass our parameters. We can then use the functions of our car object.\nmyCar1.print_info()\r## Manufacturer: Tesla1, Model: Model X1, HP; 5251\rmyCar1.print_car_amount()\r## Amount: 1\rThe results look like this:\rManufacturer: Tesla, Model: Model X, HP; 525\rAmount: 1\rWhat you can also do is directly access the attributes of an object.\nprint (myCar1.manufacturer)\r## Tesla1\rprint (myCar1.model)\r## Model X1\rprint (myCar1.hp)\r## 5251\rNow we can create some more cars and see how the amount changes.\nmyCar1 = Car( \u0026#39;Tesla1\u0026#39; , \u0026#39;Model X1\u0026#39; , 525 )\r## Object gets deleted!\rmyCar2 = Car( \u0026#39;BMW1\u0026#39; , \u0026#39;X31\u0026#39; , 2001 )\rmyCar3 = Car( \u0026#39;VW1\u0026#39; , \u0026#39;Golf1\u0026#39; , 1001)\rmyCar4 = Car( \u0026#39;Porsche1\u0026#39; , \u0026#39;9111\u0026#39; , 5201 )\rdel myCar3\r## Object gets deleted!\rmyCar1.print_car_amount()\r## Amount: 3\rHere we first create four different car objects. We then delete one of them and finally we print out the car amount. The result is the following:\rObject gets deleted!\rAmount: 3\rNotice that all the objects get deleted automatically when our program ends. But we can manually delete them before that happens by using the del keyword.\n\rHIDDEN ATTRIBUTES\rIf we want to create hidden attributes that can only be accessed within the class, we can do this with underlines .\nclass MyClass:\rdef __init__ ( self ):\rself.__hidden = \u0026#39;Hello\u0026#39;\rprint ( self .__hidden) # Works\rm1 = MyClass()\r# print (m1.__hidden) # Doesn\u0026#39;t Work \r## Hello\rBy putting two underlines before the attribute name, we make it invisible from outside the class. The first print function works because it is inside of the class. But when we try to access this attribute from the object, we can’t.\n\rINHERITANCE\rOne very important and powerful concept of object-oriented programming is inheritance . It allows us to use existing classes and to extend them with new attributes and functions.\rFor example, we could have the parent class which represents a Person and then we could have many child classes like Dancer, Policeman, Artist etc. All of these would be considered a person and they would have the same basic attributes. But they are special kinds of persons with more attributes and functions.\nclass Person:\rdef __init__ ( self , name, age):\rself .name = name\rself .age = age\rdef get_older( self , years):\rself .age += years\rclass Programmer(Person):\rdef __init__ ( self , name, age, language):\rsuper (Programmer, self ). __init__ (name, age)\rself .language = language\rdef print_language( self ):\rprint ( \u0026#39;Favorite Programming Language: {}\u0026#39;.format( self .language)) \r\r",
    "ref": "/blog/python-basics-2/"
  },{
    "title": "Python - 1",
    "date": "",
    "description": "Introduction to Python.",
    "body": "\r\rVARIABLES AND DATA TYPES\rVariables and Data types basically are just placeholders for values. In programming, that’s the same. The difference is that we have a lot of different data types, and variables cannot only store values of numbers but even of whole objects.\rIn this chapter we are going to take a look at variables in Python and the differences of the individual data types. Also, we will talk about type conversions.\nNUMERICAL DATA TYPES\rThe types you probably already know from mathematics are numerical data types. There are different kinds of numbers that can be used for mathematical operations.\n\r\rNUMERICAL DATA TYPES\r\r\r\r\r\rInteger\rint\rwhole number\r\rFloat\rfloat\rfloating point number\r\rComplex\rcomplex\rcomplex number\r\r\r\rAs you can see, it’s quite simple. An integer is just a regular whole number, which we can do basic calculations with. A float extends the integer and allows decimal places because it is a floating point number. And a complex number is what just a number that has a real and an imaginary component. If you don’t understand complex numbers mathematically, forget about them. You don’t need them for your programming right now.\n\rSTRINGS\rA string defines characters sequences. Our text that we printed in the last chapter was a string. Strings always need to be surrounded by quotation marks. Otherwise the interpreter will not realize that they are meant to be treated like text. The keyword for String in Python is str .\n\rBOOLEANS\rBoolean are the most simple data type in Python. They can only have one of two values, namely True or False . It’s a binary data type. We will use it a lot when we get to conditions and loops. The keyword here is bool .\n\rSEQUENCES\rSequences are a topic that we will cover in a later chapter. But since sequences are also data types we will at least mention that they exist.\n\r\rSEQUENCE TYPES\r\r\r\r\r\rList\rlist\rColection of values\r\rTuple\rtuple\rImutable list\r\rDictionary\rdict\rList of key nd value pairs\r\r\r\r\rCREATING VARIABLES\rCreating variables in Python is very simple. We just choose a name and assign a value.\nmyNumber = 10\rmyText = \u0026#39;Hello\u0026#39; \rHere, we defined two variables. The first one is an integer and the second one a string. You can basically choose whatever name you want but there are some limitations. For example you are not allowed to use reserved keywords like int or dict . Also, the name is not allowed to start with a number or a special character other than the underline.\n\rUSING VARIABLES\rNow that we have defined our variables, we can start to use them. For example, we could print the values.\nprint (myNumber)\r## 10\rprint (myText)\r## Hello\rSince we are not using quotation marks, the text in the parentheses is treated like a variable name. Therefore, the interpreter prints out the values 10 and “Hello” .\n\rTYPECASTING\rSometimes, we will get a value in a data type that we can’t work with properly. For example we might get a string as an input but that string contains a number as its value. Here “10” is not same to 10 . We can’t do calculations with a string, even if the text represents a number. For that reason we need to typecast.\nvalue = \u0026#39;10\u0026#39;\rnumber = int (value)\rTypecasting is done by using the specific data type function. In this case we are converting a string to an integer by using the int keyword. You can also reverse this by using the str keyword. This is a very important thing and we will need it quite often.\n\r\rPython loops and types\r\r1. For loop\rnumbers = [10,20,30,40]\rfor num in numbers:\rprint(num)\r\r## 10\r## 20\r## 30\r## 40\rfor num in range(10,41,10):\rprint(num)\r## 10\r## 20\r## 30\r## 40\r\r2. While loop\rnumber = 0\rwhile number \u0026lt; 10:\rnumber += 1\rif number == 5:\rbreak\rprint(number)\r## 1\r## 2\r## 3\r## 4\rnum = 0\rwhile num \u0026lt; 10:\rnum += 1\rif num == 5:\rcontinue\rprint(num)\r## 1\r## 2\r## 3\r## 4\r## 6\r## 7\r## 8\r## 9\r## 10\r\r3. Sequences - Lists\rnumbers = [10, 20, 30 ,40]\rnames = [\u0026#39;Arun\u0026#39;,\u0026#39;Varun\u0026#39;,\u0026#39;Karun\u0026#39;]\rmixed = [10,\u0026#39;Arun\u0026#39;, 28.3,True ]\rprint(numbers[3])\r## 40\rprint(names[0])\r## Arun\rprint(mixed[3])\r## True\rnumbers[3] = 3\rnames[2] = \u0026#39;Bob\u0026#39;\rprint(numbers[3])\r## 3\rprint(names[2])\r## Bob\r\r4. Sequences - Lists - Operations\r\r\rLIST OPERATIONS\r\r\r\r\rOPERATION\rRESULT\r\r[10, 20, 30] + [40, 50, 60]\r[10, 20, 30, 40, 50, 60]\r\r[10, “Bob”] * 3\r[10, “Bob”, 10, “Bob”, 10, “Bob”]\r\r\r\r\r5. Sequences - Lists - Functions\r\r\rLIST FUNCTIONS\r\r\r\r\rFUNCTION\rDESCRIPTION\r\rlen(list)\rReturns the length of a list\r\rmax(list)\rReturns the item with maximum value\r\rmin(list)\rReturns the item with minimum value\r\rlist(element)\rTypecasts element into list\r\r\r\r\r6. Sequences - Lists - METHODS\r\r\rLIST METHODS\r\r\r\r\rMETHOD\rDESCRIPTION\r\rlist.append(x)\rAppends element to the list\r\rlist.count(x)\rCounts how many times an element appears in the list\r\rlist.index(x)\rReturns the first index at which the given element occurs\r\rlist.pop()\rRemoves and returns last element\r\rlist.reverse()\rReverses the order of the elements\r\rlist.sort()\rSorts the elements of a list\r\r\r\r\r7. Sequences - Tupples\rtpl = (10,20,30)\rlen(tpl)\r## 3\rmax(tpl)\r## 30\rmin(tpl)\r## 10\r\r",
    "ref": "/blog/python-basics/"
  },{
    "title": "Kontakt",
    "date": "",
    "description": "",
    "body": "",
    "ref": "/contact/"
  }]
